// Generated from Cypher.g4 by ANTLR 4.7.

package parser // Cypher

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 129, 1561,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 3, 2, 5, 2, 208, 10, 2, 3, 2, 3, 2, 5, 2, 212,
	10, 2, 3, 2, 5, 2, 215, 10, 2, 3, 2, 5, 2, 218, 10, 2, 3, 2, 3, 2, 3, 3,
	3, 3, 3, 4, 3, 4, 5, 4, 226, 10, 4, 3, 5, 3, 5, 5, 5, 230, 10, 5, 3, 5,
	7, 5, 233, 10, 5, 12, 5, 14, 5, 236, 11, 5, 3, 6, 3, 6, 3, 6, 3, 6, 5,
	6, 242, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 247, 10, 6, 3, 6, 5, 6, 250, 10,
	6, 3, 7, 3, 7, 5, 7, 254, 10, 7, 3, 8, 3, 8, 5, 8, 258, 10, 8, 7, 8, 260,
	10, 8, 12, 8, 14, 8, 263, 11, 8, 3, 8, 3, 8, 3, 8, 5, 8, 268, 10, 8, 7,
	8, 270, 10, 8, 12, 8, 14, 8, 273, 11, 8, 3, 8, 3, 8, 5, 8, 277, 10, 8,
	3, 8, 7, 8, 280, 10, 8, 12, 8, 14, 8, 283, 11, 8, 3, 8, 5, 8, 286, 10,
	8, 3, 8, 5, 8, 289, 10, 8, 5, 8, 291, 10, 8, 3, 9, 6, 9, 294, 10, 9, 13,
	9, 14, 9, 295, 3, 9, 3, 9, 3, 10, 3, 10, 5, 10, 302, 10, 10, 7, 10, 304,
	10, 10, 12, 10, 14, 10, 307, 11, 10, 3, 10, 3, 10, 5, 10, 311, 10, 10,
	7, 10, 313, 10, 10, 12, 10, 14, 10, 316, 11, 10, 3, 10, 3, 10, 5, 10, 320,
	10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 327, 10, 11, 3, 12, 3,
	12, 3, 12, 5, 12, 332, 10, 12, 3, 13, 3, 13, 5, 13, 336, 10, 13, 3, 13,
	3, 13, 5, 13, 340, 10, 13, 3, 13, 3, 13, 5, 13, 344, 10, 13, 3, 13, 5,
	13, 347, 10, 13, 3, 14, 3, 14, 5, 14, 351, 10, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 15, 3, 15, 5, 15, 361, 10, 15, 3, 15, 3, 15, 3,
	15, 7, 15, 366, 10, 15, 12, 15, 14, 15, 369, 11, 15, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 381, 10, 16, 3,
	17, 3, 17, 5, 17, 385, 10, 17, 3, 17, 3, 17, 3, 18, 3, 18, 5, 18, 391,
	10, 18, 3, 18, 3, 18, 3, 18, 7, 18, 396, 10, 18, 12, 18, 14, 18, 399, 11,
	18, 3, 19, 3, 19, 5, 19, 403, 10, 19, 3, 19, 3, 19, 5, 19, 407, 10, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 413, 10, 19, 3, 19, 3, 19, 5, 19, 417,
	10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 423, 10, 19, 3, 19, 3, 19, 5,
	19, 427, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 433, 10, 19, 3, 19,
	3, 19, 5, 19, 437, 10, 19, 3, 20, 3, 20, 5, 20, 441, 10, 20, 3, 20, 3,
	20, 5, 20, 445, 10, 20, 3, 20, 3, 20, 5, 20, 449, 10, 20, 3, 20, 3, 20,
	5, 20, 453, 10, 20, 3, 20, 7, 20, 456, 10, 20, 12, 20, 14, 20, 459, 11,
	20, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 465, 10, 21, 3, 21, 3, 21, 5, 21,
	469, 10, 21, 3, 21, 7, 21, 472, 10, 21, 12, 21, 14, 21, 475, 11, 21, 3,
	22, 3, 22, 3, 22, 3, 22, 5, 22, 481, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23,
	5, 23, 487, 10, 23, 3, 23, 3, 23, 3, 23, 5, 23, 492, 10, 23, 3, 24, 3,
	24, 3, 24, 3, 24, 5, 24, 498, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24,
	504, 10, 24, 3, 25, 3, 25, 3, 25, 5, 25, 509, 10, 25, 3, 25, 3, 25, 5,
	25, 513, 10, 25, 3, 25, 7, 25, 516, 10, 25, 12, 25, 14, 25, 519, 11, 25,
	5, 25, 521, 10, 25, 3, 25, 5, 25, 524, 10, 25, 3, 25, 5, 25, 527, 10, 25,
	3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 534, 10, 26, 3, 26, 3, 26, 3,
	27, 3, 27, 5, 27, 540, 10, 27, 3, 27, 5, 27, 543, 10, 27, 3, 27, 3, 27,
	3, 27, 5, 27, 548, 10, 27, 3, 27, 5, 27, 551, 10, 27, 3, 28, 3, 28, 5,
	28, 555, 10, 28, 3, 28, 5, 28, 558, 10, 28, 3, 28, 3, 28, 3, 28, 3, 29,
	3, 29, 3, 29, 5, 29, 566, 10, 29, 3, 29, 3, 29, 5, 29, 570, 10, 29, 3,
	29, 3, 29, 5, 29, 574, 10, 29, 3, 30, 3, 30, 5, 30, 578, 10, 30, 3, 30,
	3, 30, 5, 30, 582, 10, 30, 3, 30, 7, 30, 585, 10, 30, 12, 30, 14, 30, 588,
	11, 30, 3, 30, 3, 30, 5, 30, 592, 10, 30, 3, 30, 3, 30, 5, 30, 596, 10,
	30, 3, 30, 7, 30, 599, 10, 30, 12, 30, 14, 30, 602, 11, 30, 5, 30, 604,
	10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 613, 10,
	31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 622, 10, 32,
	3, 32, 7, 32, 625, 10, 32, 12, 32, 14, 32, 628, 11, 32, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 5, 35, 640, 10, 35,
	3, 35, 5, 35, 643, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 5,
	37, 651, 10, 37, 3, 37, 3, 37, 5, 37, 655, 10, 37, 3, 37, 7, 37, 658, 10,
	37, 12, 37, 14, 37, 661, 11, 37, 3, 38, 3, 38, 5, 38, 665, 10, 38, 3, 38,
	3, 38, 5, 38, 669, 10, 38, 3, 38, 3, 38, 3, 38, 5, 38, 674, 10, 38, 3,
	39, 3, 39, 3, 40, 3, 40, 5, 40, 680, 10, 40, 3, 40, 7, 40, 683, 10, 40,
	12, 40, 14, 40, 686, 11, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 692, 10,
	40, 3, 41, 3, 41, 5, 41, 696, 10, 41, 3, 41, 3, 41, 5, 41, 700, 10, 41,
	5, 41, 702, 10, 41, 3, 41, 3, 41, 5, 41, 706, 10, 41, 5, 41, 708, 10, 41,
	3, 41, 3, 41, 5, 41, 712, 10, 41, 5, 41, 714, 10, 41, 3, 41, 3, 41, 3,
	42, 3, 42, 5, 42, 720, 10, 42, 3, 42, 3, 42, 3, 43, 3, 43, 5, 43, 726,
	10, 43, 3, 43, 3, 43, 5, 43, 730, 10, 43, 3, 43, 5, 43, 733, 10, 43, 3,
	43, 5, 43, 736, 10, 43, 3, 43, 3, 43, 5, 43, 740, 10, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 5, 43, 746, 10, 43, 3, 43, 3, 43, 5, 43, 750, 10, 43, 3,
	43, 5, 43, 753, 10, 43, 3, 43, 5, 43, 756, 10, 43, 3, 43, 3, 43, 3, 43,
	3, 43, 5, 43, 762, 10, 43, 3, 43, 5, 43, 765, 10, 43, 3, 43, 5, 43, 768,
	10, 43, 3, 43, 3, 43, 5, 43, 772, 10, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5,
	43, 778, 10, 43, 3, 43, 5, 43, 781, 10, 43, 3, 43, 5, 43, 784, 10, 43,
	3, 43, 3, 43, 5, 43, 788, 10, 43, 3, 44, 3, 44, 5, 44, 792, 10, 44, 3,
	44, 3, 44, 5, 44, 796, 10, 44, 5, 44, 798, 10, 44, 3, 44, 3, 44, 5, 44,
	802, 10, 44, 5, 44, 804, 10, 44, 3, 44, 5, 44, 807, 10, 44, 3, 44, 3, 44,
	5, 44, 811, 10, 44, 5, 44, 813, 10, 44, 3, 44, 3, 44, 3, 45, 3, 45, 5,
	45, 819, 10, 45, 3, 46, 3, 46, 5, 46, 823, 10, 46, 3, 46, 3, 46, 5, 46,
	827, 10, 46, 3, 46, 3, 46, 5, 46, 831, 10, 46, 3, 46, 5, 46, 834, 10, 46,
	3, 46, 7, 46, 837, 10, 46, 12, 46, 14, 46, 840, 11, 46, 3, 47, 3, 47, 5,
	47, 844, 10, 47, 3, 47, 7, 47, 847, 10, 47, 12, 47, 14, 47, 850, 11, 47,
	3, 48, 3, 48, 5, 48, 854, 10, 48, 3, 48, 3, 48, 3, 49, 3, 49, 5, 49, 860,
	10, 49, 3, 49, 3, 49, 5, 49, 864, 10, 49, 5, 49, 866, 10, 49, 3, 49, 3,
	49, 5, 49, 870, 10, 49, 3, 49, 3, 49, 5, 49, 874, 10, 49, 5, 49, 876, 10,
	49, 5, 49, 878, 10, 49, 3, 50, 3, 50, 3, 51, 3, 51, 3, 52, 3, 52, 3, 53,
	3, 53, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 7, 55, 895, 10,
	55, 12, 55, 14, 55, 898, 11, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 7,
	56, 905, 10, 56, 12, 56, 14, 56, 908, 11, 56, 3, 57, 3, 57, 3, 57, 3, 57,
	3, 57, 7, 57, 915, 10, 57, 12, 57, 14, 57, 918, 11, 57, 3, 58, 3, 58, 5,
	58, 922, 10, 58, 7, 58, 924, 10, 58, 12, 58, 14, 58, 927, 11, 58, 3, 58,
	3, 58, 3, 59, 3, 59, 5, 59, 933, 10, 59, 3, 59, 7, 59, 936, 10, 59, 12,
	59, 14, 59, 939, 11, 59, 3, 60, 3, 60, 5, 60, 943, 10, 60, 3, 60, 3, 60,
	5, 60, 947, 10, 60, 3, 60, 3, 60, 5, 60, 951, 10, 60, 3, 60, 3, 60, 5,
	60, 955, 10, 60, 3, 60, 7, 60, 958, 10, 60, 12, 60, 14, 60, 961, 11, 60,
	3, 61, 3, 61, 5, 61, 965, 10, 61, 3, 61, 3, 61, 5, 61, 969, 10, 61, 3,
	61, 3, 61, 5, 61, 973, 10, 61, 3, 61, 3, 61, 5, 61, 977, 10, 61, 3, 61,
	3, 61, 5, 61, 981, 10, 61, 3, 61, 3, 61, 5, 61, 985, 10, 61, 3, 61, 7,
	61, 988, 10, 61, 12, 61, 14, 61, 991, 11, 61, 3, 62, 3, 62, 5, 62, 995,
	10, 62, 3, 62, 3, 62, 5, 62, 999, 10, 62, 3, 62, 7, 62, 1002, 10, 62, 12,
	62, 14, 62, 1005, 11, 62, 3, 63, 3, 63, 5, 63, 1009, 10, 63, 7, 63, 1011,
	10, 63, 12, 63, 14, 63, 1014, 11, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64,
	3, 64, 7, 64, 1022, 10, 64, 12, 64, 14, 64, 1025, 11, 64, 3, 65, 3, 65,
	3, 65, 5, 65, 1030, 10, 65, 3, 65, 3, 65, 5, 65, 1034, 10, 65, 3, 65, 3,
	65, 3, 65, 3, 65, 3, 65, 5, 65, 1041, 10, 65, 3, 65, 3, 65, 5, 65, 1045,
	10, 65, 3, 65, 3, 65, 5, 65, 1049, 10, 65, 3, 65, 5, 65, 1052, 10, 65,
	3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5,
	66, 1064, 10, 66, 3, 66, 5, 66, 1067, 10, 66, 3, 66, 3, 66, 3, 67, 3, 67,
	3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 1081, 10,
	67, 3, 68, 3, 68, 5, 68, 1085, 10, 68, 3, 68, 7, 68, 1088, 10, 68, 12,
	68, 14, 68, 1091, 11, 68, 3, 68, 5, 68, 1094, 10, 68, 3, 68, 5, 68, 1097,
	10, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1104, 10, 69, 3, 69,
	3, 69, 5, 69, 1108, 10, 69, 3, 69, 3, 69, 5, 69, 1112, 10, 69, 3, 69, 3,
	69, 3, 69, 3, 69, 3, 69, 5, 69, 1119, 10, 69, 3, 69, 3, 69, 5, 69, 1123,
	10, 69, 3, 69, 3, 69, 5, 69, 1127, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69,
	5, 69, 1133, 10, 69, 3, 69, 3, 69, 5, 69, 1137, 10, 69, 3, 69, 3, 69, 5,
	69, 1141, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1147, 10, 69, 3, 69,
	3, 69, 5, 69, 1151, 10, 69, 3, 69, 3, 69, 5, 69, 1155, 10, 69, 3, 69, 3,
	69, 3, 69, 3, 69, 5, 69, 1161, 10, 69, 3, 69, 3, 69, 5, 69, 1165, 10, 69,
	3, 69, 3, 69, 5, 69, 1169, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3,
	69, 5, 69, 1177, 10, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70,
	1185, 10, 70, 3, 71, 3, 71, 3, 72, 3, 72, 5, 72, 1191, 10, 72, 3, 72, 3,
	72, 5, 72, 1195, 10, 72, 3, 72, 3, 72, 5, 72, 1199, 10, 72, 3, 72, 3, 72,
	5, 72, 1203, 10, 72, 7, 72, 1205, 10, 72, 12, 72, 14, 72, 1208, 11, 72,
	5, 72, 1210, 10, 72, 3, 72, 3, 72, 3, 73, 3, 73, 5, 73, 1216, 10, 73, 3,
	73, 3, 73, 3, 73, 5, 73, 1221, 10, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1226,
	10, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1231, 10, 73, 3, 73, 3, 73, 3, 73,
	5, 73, 1236, 10, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1241, 10, 73, 3, 73, 5,
	73, 1244, 10, 73, 3, 74, 3, 74, 5, 74, 1248, 10, 74, 3, 74, 3, 74, 5, 74,
	1252, 10, 74, 3, 74, 3, 74, 3, 75, 3, 75, 5, 75, 1258, 10, 75, 3, 75, 6,
	75, 1261, 10, 75, 13, 75, 14, 75, 1262, 3, 76, 3, 76, 5, 76, 1267, 10,
	76, 3, 76, 5, 76, 1270, 10, 76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77,
	3, 78, 3, 78, 5, 78, 1280, 10, 78, 3, 78, 3, 78, 5, 78, 1284, 10, 78, 3,
	78, 3, 78, 5, 78, 1288, 10, 78, 5, 78, 1290, 10, 78, 3, 78, 3, 78, 5, 78,
	1294, 10, 78, 3, 78, 3, 78, 5, 78, 1298, 10, 78, 3, 78, 3, 78, 5, 78, 1302,
	10, 78, 7, 78, 1304, 10, 78, 12, 78, 14, 78, 1307, 11, 78, 5, 78, 1309,
	10, 78, 3, 78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 1317, 10, 79,
	3, 80, 3, 80, 5, 80, 1321, 10, 80, 3, 80, 3, 80, 5, 80, 1325, 10, 80, 3,
	80, 3, 80, 5, 80, 1329, 10, 80, 3, 80, 3, 80, 5, 80, 1333, 10, 80, 3, 80,
	3, 80, 5, 80, 1337, 10, 80, 7, 80, 1339, 10, 80, 12, 80, 14, 80, 1342,
	11, 80, 5, 80, 1344, 10, 80, 3, 80, 3, 80, 3, 81, 3, 81, 3, 82, 3, 82,
	3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 7, 84, 1358, 10, 84, 12, 84,
	14, 84, 1361, 11, 84, 3, 85, 3, 85, 5, 85, 1365, 10, 85, 3, 85, 3, 85,
	5, 85, 1369, 10, 85, 3, 85, 3, 85, 5, 85, 1373, 10, 85, 3, 85, 5, 85, 1376,
	10, 85, 3, 85, 5, 85, 1379, 10, 85, 3, 85, 3, 85, 3, 86, 3, 86, 5, 86,
	1385, 10, 86, 3, 86, 3, 86, 5, 86, 1389, 10, 86, 3, 86, 3, 86, 5, 86, 1393,
	10, 86, 5, 86, 1395, 10, 86, 3, 86, 3, 86, 5, 86, 1399, 10, 86, 3, 86,
	3, 86, 5, 86, 1403, 10, 86, 3, 86, 3, 86, 5, 86, 1407, 10, 86, 5, 86, 1409,
	10, 86, 3, 86, 3, 86, 5, 86, 1413, 10, 86, 3, 86, 3, 86, 5, 86, 1417, 10,
	86, 3, 86, 3, 86, 3, 87, 3, 87, 5, 87, 1423, 10, 87, 3, 87, 3, 87, 3, 88,
	3, 88, 5, 88, 1429, 10, 88, 3, 88, 6, 88, 1432, 10, 88, 13, 88, 14, 88,
	1433, 3, 88, 3, 88, 5, 88, 1438, 10, 88, 3, 88, 3, 88, 5, 88, 1442, 10,
	88, 3, 88, 6, 88, 1445, 10, 88, 13, 88, 14, 88, 1446, 5, 88, 1449, 10,
	88, 3, 88, 5, 88, 1452, 10, 88, 3, 88, 3, 88, 5, 88, 1456, 10, 88, 3, 88,
	5, 88, 1459, 10, 88, 3, 88, 5, 88, 1462, 10, 88, 3, 88, 3, 88, 3, 89, 3,
	89, 5, 89, 1468, 10, 89, 3, 89, 3, 89, 5, 89, 1472, 10, 89, 3, 89, 3, 89,
	5, 89, 1476, 10, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 91, 3, 91, 5, 91, 1484,
	10, 91, 3, 92, 3, 92, 5, 92, 1488, 10, 92, 3, 92, 3, 92, 5, 92, 1492, 10,
	92, 3, 92, 3, 92, 5, 92, 1496, 10, 92, 3, 92, 3, 92, 5, 92, 1500, 10, 92,
	3, 92, 3, 92, 5, 92, 1504, 10, 92, 3, 92, 3, 92, 5, 92, 1508, 10, 92, 3,
	92, 3, 92, 5, 92, 1512, 10, 92, 3, 92, 3, 92, 5, 92, 1516, 10, 92, 7, 92,
	1518, 10, 92, 12, 92, 14, 92, 1521, 11, 92, 5, 92, 1523, 10, 92, 3, 92,
	3, 92, 3, 93, 3, 93, 3, 93, 5, 93, 1530, 10, 93, 3, 94, 3, 94, 5, 94, 1534,
	10, 94, 3, 94, 6, 94, 1537, 10, 94, 13, 94, 14, 94, 1538, 3, 95, 3, 95,
	3, 96, 3, 96, 3, 97, 3, 97, 3, 98, 3, 98, 5, 98, 1549, 10, 98, 3, 99, 3,
	99, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 3, 103, 3, 103, 3,
	103, 2, 2, 104, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
	32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
	68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
	104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132,
	134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162,
	164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,
	194, 196, 198, 200, 202, 204, 2, 12, 3, 2, 70, 73, 3, 2, 15, 16, 3, 2,
	89, 90, 3, 2, 99, 101, 3, 2, 109, 110, 6, 2, 48, 60, 63, 84, 89, 96, 111,
	120, 6, 2, 85, 88, 102, 102, 121, 123, 126, 126, 4, 2, 21, 21, 29, 32,
	4, 2, 22, 22, 33, 36, 4, 2, 16, 16, 37, 47, 2, 1775, 2, 207, 3, 2, 2, 2,
	4, 221, 3, 2, 2, 2, 6, 225, 3, 2, 2, 2, 8, 227, 3, 2, 2, 2, 10, 249, 3,
	2, 2, 2, 12, 253, 3, 2, 2, 2, 14, 290, 3, 2, 2, 2, 16, 293, 3, 2, 2, 2,
	18, 305, 3, 2, 2, 2, 20, 326, 3, 2, 2, 2, 22, 331, 3, 2, 2, 2, 24, 335,
	3, 2, 2, 2, 26, 348, 3, 2, 2, 2, 28, 358, 3, 2, 2, 2, 30, 380, 3, 2, 2,
	2, 32, 382, 3, 2, 2, 2, 34, 388, 3, 2, 2, 2, 36, 436, 3, 2, 2, 2, 38, 440,
	3, 2, 2, 2, 40, 460, 3, 2, 2, 2, 42, 480, 3, 2, 2, 2, 44, 482, 3, 2, 2,
	2, 46, 493, 3, 2, 2, 2, 48, 520, 3, 2, 2, 2, 50, 533, 3, 2, 2, 2, 52, 537,
	3, 2, 2, 2, 54, 552, 3, 2, 2, 2, 56, 562, 3, 2, 2, 2, 58, 603, 3, 2, 2,
	2, 60, 612, 3, 2, 2, 2, 62, 614, 3, 2, 2, 2, 64, 629, 3, 2, 2, 2, 66, 633,
	3, 2, 2, 2, 68, 637, 3, 2, 2, 2, 70, 644, 3, 2, 2, 2, 72, 648, 3, 2, 2,
	2, 74, 673, 3, 2, 2, 2, 76, 675, 3, 2, 2, 2, 78, 691, 3, 2, 2, 2, 80, 693,
	3, 2, 2, 2, 82, 717, 3, 2, 2, 2, 84, 787, 3, 2, 2, 2, 86, 789, 3, 2, 2,
	2, 88, 818, 3, 2, 2, 2, 90, 820, 3, 2, 2, 2, 92, 841, 3, 2, 2, 2, 94, 851,
	3, 2, 2, 2, 96, 857, 3, 2, 2, 2, 98, 879, 3, 2, 2, 2, 100, 881, 3, 2, 2,
	2, 102, 883, 3, 2, 2, 2, 104, 885, 3, 2, 2, 2, 106, 887, 3, 2, 2, 2, 108,
	889, 3, 2, 2, 2, 110, 899, 3, 2, 2, 2, 112, 909, 3, 2, 2, 2, 114, 925,
	3, 2, 2, 2, 116, 930, 3, 2, 2, 2, 118, 940, 3, 2, 2, 2, 120, 962, 3, 2,
	2, 2, 122, 992, 3, 2, 2, 2, 124, 1012, 3, 2, 2, 2, 126, 1017, 3, 2, 2,
	2, 128, 1051, 3, 2, 2, 2, 130, 1063, 3, 2, 2, 2, 132, 1080, 3, 2, 2, 2,
	134, 1082, 3, 2, 2, 2, 136, 1176, 3, 2, 2, 2, 138, 1184, 3, 2, 2, 2, 140,
	1186, 3, 2, 2, 2, 142, 1188, 3, 2, 2, 2, 144, 1243, 3, 2, 2, 2, 146, 1245,
	3, 2, 2, 2, 148, 1255, 3, 2, 2, 2, 150, 1264, 3, 2, 2, 2, 152, 1271, 3,
	2, 2, 2, 154, 1277, 3, 2, 2, 2, 156, 1316, 3, 2, 2, 2, 158, 1318, 3, 2,
	2, 2, 160, 1347, 3, 2, 2, 2, 162, 1349, 3, 2, 2, 2, 164, 1351, 3, 2, 2,
	2, 166, 1359, 3, 2, 2, 2, 168, 1362, 3, 2, 2, 2, 170, 1382, 3, 2, 2, 2,
	172, 1420, 3, 2, 2, 2, 174, 1448, 3, 2, 2, 2, 176, 1465, 3, 2, 2, 2, 178,
	1479, 3, 2, 2, 2, 180, 1483, 3, 2, 2, 2, 182, 1485, 3, 2, 2, 2, 184, 1526,
	3, 2, 2, 2, 186, 1531, 3, 2, 2, 2, 188, 1540, 3, 2, 2, 2, 190, 1542, 3,
	2, 2, 2, 192, 1544, 3, 2, 2, 2, 194, 1548, 3, 2, 2, 2, 196, 1550, 3, 2,
	2, 2, 198, 1552, 3, 2, 2, 2, 200, 1554, 3, 2, 2, 2, 202, 1556, 3, 2, 2,
	2, 204, 1558, 3, 2, 2, 2, 206, 208, 7, 127, 2, 2, 207, 206, 3, 2, 2, 2,
	207, 208, 3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 214, 5, 4, 3, 2, 210,
	212, 7, 127, 2, 2, 211, 210, 3, 2, 2, 2, 211, 212, 3, 2, 2, 2, 212, 213,
	3, 2, 2, 2, 213, 215, 7, 3, 2, 2, 214, 211, 3, 2, 2, 2, 214, 215, 3, 2,
	2, 2, 215, 217, 3, 2, 2, 2, 216, 218, 7, 127, 2, 2, 217, 216, 3, 2, 2,
	2, 217, 218, 3, 2, 2, 2, 218, 219, 3, 2, 2, 2, 219, 220, 7, 2, 2, 3, 220,
	3, 3, 2, 2, 2, 221, 222, 5, 6, 4, 2, 222, 5, 3, 2, 2, 2, 223, 226, 5, 8,
	5, 2, 224, 226, 5, 46, 24, 2, 225, 223, 3, 2, 2, 2, 225, 224, 3, 2, 2,
	2, 226, 7, 3, 2, 2, 2, 227, 234, 5, 12, 7, 2, 228, 230, 7, 127, 2, 2, 229,
	228, 3, 2, 2, 2, 229, 230, 3, 2, 2, 2, 230, 231, 3, 2, 2, 2, 231, 233,
	5, 10, 6, 2, 232, 229, 3, 2, 2, 2, 233, 236, 3, 2, 2, 2, 234, 232, 3, 2,
	2, 2, 234, 235, 3, 2, 2, 2, 235, 9, 3, 2, 2, 2, 236, 234, 3, 2, 2, 2, 237,
	238, 7, 48, 2, 2, 238, 239, 7, 127, 2, 2, 239, 241, 7, 49, 2, 2, 240, 242,
	7, 127, 2, 2, 241, 240, 3, 2, 2, 2, 241, 242, 3, 2, 2, 2, 242, 243, 3,
	2, 2, 2, 243, 250, 5, 12, 7, 2, 244, 246, 7, 48, 2, 2, 245, 247, 7, 127,
	2, 2, 246, 245, 3, 2, 2, 2, 246, 247, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2,
	248, 250, 5, 12, 7, 2, 249, 237, 3, 2, 2, 2, 249, 244, 3, 2, 2, 2, 250,
	11, 3, 2, 2, 2, 251, 254, 5, 14, 8, 2, 252, 254, 5, 16, 9, 2, 253, 251,
	3, 2, 2, 2, 253, 252, 3, 2, 2, 2, 254, 13, 3, 2, 2, 2, 255, 257, 5, 22,
	12, 2, 256, 258, 7, 127, 2, 2, 257, 256, 3, 2, 2, 2, 257, 258, 3, 2, 2,
	2, 258, 260, 3, 2, 2, 2, 259, 255, 3, 2, 2, 2, 260, 263, 3, 2, 2, 2, 261,
	259, 3, 2, 2, 2, 261, 262, 3, 2, 2, 2, 262, 264, 3, 2, 2, 2, 263, 261,
	3, 2, 2, 2, 264, 291, 5, 54, 28, 2, 265, 267, 5, 22, 12, 2, 266, 268, 7,
	127, 2, 2, 267, 266, 3, 2, 2, 2, 267, 268, 3, 2, 2, 2, 268, 270, 3, 2,
	2, 2, 269, 265, 3, 2, 2, 2, 270, 273, 3, 2, 2, 2, 271, 269, 3, 2, 2, 2,
	271, 272, 3, 2, 2, 2, 272, 274, 3, 2, 2, 2, 273, 271, 3, 2, 2, 2, 274,
	281, 5, 20, 11, 2, 275, 277, 7, 127, 2, 2, 276, 275, 3, 2, 2, 2, 276, 277,
	3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278, 280, 5, 20, 11, 2, 279, 276, 3,
	2, 2, 2, 280, 283, 3, 2, 2, 2, 281, 279, 3, 2, 2, 2, 281, 282, 3, 2, 2,
	2, 282, 288, 3, 2, 2, 2, 283, 281, 3, 2, 2, 2, 284, 286, 7, 127, 2, 2,
	285, 284, 3, 2, 2, 2, 285, 286, 3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287,
	289, 5, 54, 28, 2, 288, 285, 3, 2, 2, 2, 288, 289, 3, 2, 2, 2, 289, 291,
	3, 2, 2, 2, 290, 261, 3, 2, 2, 2, 290, 271, 3, 2, 2, 2, 291, 15, 3, 2,
	2, 2, 292, 294, 5, 18, 10, 2, 293, 292, 3, 2, 2, 2, 294, 295, 3, 2, 2,
	2, 295, 293, 3, 2, 2, 2, 295, 296, 3, 2, 2, 2, 296, 297, 3, 2, 2, 2, 297,
	298, 5, 14, 8, 2, 298, 17, 3, 2, 2, 2, 299, 301, 5, 22, 12, 2, 300, 302,
	7, 127, 2, 2, 301, 300, 3, 2, 2, 2, 301, 302, 3, 2, 2, 2, 302, 304, 3,
	2, 2, 2, 303, 299, 3, 2, 2, 2, 304, 307, 3, 2, 2, 2, 305, 303, 3, 2, 2,
	2, 305, 306, 3, 2, 2, 2, 306, 314, 3, 2, 2, 2, 307, 305, 3, 2, 2, 2, 308,
	310, 5, 20, 11, 2, 309, 311, 7, 127, 2, 2, 310, 309, 3, 2, 2, 2, 310, 311,
	3, 2, 2, 2, 311, 313, 3, 2, 2, 2, 312, 308, 3, 2, 2, 2, 313, 316, 3, 2,
	2, 2, 314, 312, 3, 2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 317, 3, 2, 2, 2,
	316, 314, 3, 2, 2, 2, 317, 319, 5, 52, 27, 2, 318, 320, 7, 127, 2, 2, 319,
	318, 3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 320, 19, 3, 2, 2, 2, 321, 327, 5,
	32, 17, 2, 322, 327, 5, 28, 15, 2, 323, 327, 5, 38, 20, 2, 324, 327, 5,
	34, 18, 2, 325, 327, 5, 40, 21, 2, 326, 321, 3, 2, 2, 2, 326, 322, 3, 2,
	2, 2, 326, 323, 3, 2, 2, 2, 326, 324, 3, 2, 2, 2, 326, 325, 3, 2, 2, 2,
	327, 21, 3, 2, 2, 2, 328, 332, 5, 24, 13, 2, 329, 332, 5, 26, 14, 2, 330,
	332, 5, 44, 23, 2, 331, 328, 3, 2, 2, 2, 331, 329, 3, 2, 2, 2, 331, 330,
	3, 2, 2, 2, 332, 23, 3, 2, 2, 2, 333, 334, 7, 50, 2, 2, 334, 336, 7, 127,
	2, 2, 335, 333, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 337, 3, 2, 2, 2,
	337, 339, 7, 51, 2, 2, 338, 340, 7, 127, 2, 2, 339, 338, 3, 2, 2, 2, 339,
	340, 3, 2, 2, 2, 340, 341, 3, 2, 2, 2, 341, 346, 5, 72, 37, 2, 342, 344,
	7, 127, 2, 2, 343, 342, 3, 2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 345, 3,
	2, 2, 2, 345, 347, 5, 70, 36, 2, 346, 343, 3, 2, 2, 2, 346, 347, 3, 2,
	2, 2, 347, 25, 3, 2, 2, 2, 348, 350, 7, 52, 2, 2, 349, 351, 7, 127, 2,
	2, 350, 349, 3, 2, 2, 2, 350, 351, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352,
	353, 5, 106, 54, 2, 353, 354, 7, 127, 2, 2, 354, 355, 7, 53, 2, 2, 355,
	356, 7, 127, 2, 2, 356, 357, 5, 178, 90, 2, 357, 27, 3, 2, 2, 2, 358, 360,
	7, 54, 2, 2, 359, 361, 7, 127, 2, 2, 360, 359, 3, 2, 2, 2, 360, 361, 3,
	2, 2, 2, 361, 362, 3, 2, 2, 2, 362, 367, 5, 74, 38, 2, 363, 364, 7, 127,
	2, 2, 364, 366, 5, 30, 16, 2, 365, 363, 3, 2, 2, 2, 366, 369, 3, 2, 2,
	2, 367, 365, 3, 2, 2, 2, 367, 368, 3, 2, 2, 2, 368, 29, 3, 2, 2, 2, 369,
	367, 3, 2, 2, 2, 370, 371, 7, 55, 2, 2, 371, 372, 7, 127, 2, 2, 372, 373,
	7, 51, 2, 2, 373, 374, 7, 127, 2, 2, 374, 381, 5, 34, 18, 2, 375, 376,
	7, 55, 2, 2, 376, 377, 7, 127, 2, 2, 377, 378, 7, 56, 2, 2, 378, 379, 7,
	127, 2, 2, 379, 381, 5, 34, 18, 2, 380, 370, 3, 2, 2, 2, 380, 375, 3, 2,
	2, 2, 381, 31, 3, 2, 2, 2, 382, 384, 7, 56, 2, 2, 383, 385, 7, 127, 2,
	2, 384, 383, 3, 2, 2, 2, 384, 385, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386,
	387, 5, 72, 37, 2, 387, 33, 3, 2, 2, 2, 388, 390, 7, 57, 2, 2, 389, 391,
	7, 127, 2, 2, 390, 389, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2, 391, 392, 3,
	2, 2, 2, 392, 397, 5, 36, 19, 2, 393, 394, 7, 4, 2, 2, 394, 396, 5, 36,
	19, 2, 395, 393, 3, 2, 2, 2, 396, 399, 3, 2, 2, 2, 397, 395, 3, 2, 2, 2,
	397, 398, 3, 2, 2, 2, 398, 35, 3, 2, 2, 2, 399, 397, 3, 2, 2, 2, 400, 402,
	5, 186, 94, 2, 401, 403, 7, 127, 2, 2, 402, 401, 3, 2, 2, 2, 402, 403,
	3, 2, 2, 2, 403, 404, 3, 2, 2, 2, 404, 406, 7, 5, 2, 2, 405, 407, 7, 127,
	2, 2, 406, 405, 3, 2, 2, 2, 406, 407, 3, 2, 2, 2, 407, 408, 3, 2, 2, 2,
	408, 409, 5, 106, 54, 2, 409, 437, 3, 2, 2, 2, 410, 412, 5, 178, 90, 2,
	411, 413, 7, 127, 2, 2, 412, 411, 3, 2, 2, 2, 412, 413, 3, 2, 2, 2, 413,
	414, 3, 2, 2, 2, 414, 416, 7, 5, 2, 2, 415, 417, 7, 127, 2, 2, 416, 415,
	3, 2, 2, 2, 416, 417, 3, 2, 2, 2, 417, 418, 3, 2, 2, 2, 418, 419, 5, 106,
	54, 2, 419, 437, 3, 2, 2, 2, 420, 422, 5, 178, 90, 2, 421, 423, 7, 127,
	2, 2, 422, 421, 3, 2, 2, 2, 422, 423, 3, 2, 2, 2, 423, 424, 3, 2, 2, 2,
	424, 426, 7, 6, 2, 2, 425, 427, 7, 127, 2, 2, 426, 425, 3, 2, 2, 2, 426,
	427, 3, 2, 2, 2, 427, 428, 3, 2, 2, 2, 428, 429, 5, 106, 54, 2, 429, 437,
	3, 2, 2, 2, 430, 432, 5, 178, 90, 2, 431, 433, 7, 127, 2, 2, 432, 431,
	3, 2, 2, 2, 432, 433, 3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 435, 5, 92,
	47, 2, 435, 437, 3, 2, 2, 2, 436, 400, 3, 2, 2, 2, 436, 410, 3, 2, 2, 2,
	436, 420, 3, 2, 2, 2, 436, 430, 3, 2, 2, 2, 437, 37, 3, 2, 2, 2, 438, 439,
	7, 58, 2, 2, 439, 441, 7, 127, 2, 2, 440, 438, 3, 2, 2, 2, 440, 441, 3,
	2, 2, 2, 441, 442, 3, 2, 2, 2, 442, 444, 7, 59, 2, 2, 443, 445, 7, 127,
	2, 2, 444, 443, 3, 2, 2, 2, 444, 445, 3, 2, 2, 2, 445, 446, 3, 2, 2, 2,
	446, 457, 5, 106, 54, 2, 447, 449, 7, 127, 2, 2, 448, 447, 3, 2, 2, 2,
	448, 449, 3, 2, 2, 2, 449, 450, 3, 2, 2, 2, 450, 452, 7, 4, 2, 2, 451,
	453, 7, 127, 2, 2, 452, 451, 3, 2, 2, 2, 452, 453, 3, 2, 2, 2, 453, 454,
	3, 2, 2, 2, 454, 456, 5, 106, 54, 2, 455, 448, 3, 2, 2, 2, 456, 459, 3,
	2, 2, 2, 457, 455, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 39, 3, 2, 2,
	2, 459, 457, 3, 2, 2, 2, 460, 461, 7, 60, 2, 2, 461, 462, 7, 127, 2, 2,
	462, 473, 5, 42, 22, 2, 463, 465, 7, 127, 2, 2, 464, 463, 3, 2, 2, 2, 464,
	465, 3, 2, 2, 2, 465, 466, 3, 2, 2, 2, 466, 468, 7, 4, 2, 2, 467, 469,
	7, 127, 2, 2, 468, 467, 3, 2, 2, 2, 468, 469, 3, 2, 2, 2, 469, 470, 3,
	2, 2, 2, 470, 472, 5, 42, 22, 2, 471, 464, 3, 2, 2, 2, 472, 475, 3, 2,
	2, 2, 473, 471, 3, 2, 2, 2, 473, 474, 3, 2, 2, 2, 474, 41, 3, 2, 2, 2,
	475, 473, 3, 2, 2, 2, 476, 477, 5, 178, 90, 2, 477, 478, 5, 92, 47, 2,
	478, 481, 3, 2, 2, 2, 479, 481, 5, 186, 94, 2, 480, 476, 3, 2, 2, 2, 480,
	479, 3, 2, 2, 2, 481, 43, 3, 2, 2, 2, 482, 483, 7, 61, 2, 2, 483, 484,
	7, 127, 2, 2, 484, 491, 5, 158, 80, 2, 485, 487, 7, 127, 2, 2, 486, 485,
	3, 2, 2, 2, 486, 487, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 488, 489, 7, 62,
	2, 2, 489, 490, 7, 127, 2, 2, 490, 492, 5, 48, 25, 2, 491, 486, 3, 2, 2,
	2, 491, 492, 3, 2, 2, 2, 492, 45, 3, 2, 2, 2, 493, 494, 7, 61, 2, 2, 494,
	497, 7, 127, 2, 2, 495, 498, 5, 158, 80, 2, 496, 498, 5, 160, 81, 2, 497,
	495, 3, 2, 2, 2, 497, 496, 3, 2, 2, 2, 498, 503, 3, 2, 2, 2, 499, 500,
	7, 127, 2, 2, 500, 501, 7, 62, 2, 2, 501, 502, 7, 127, 2, 2, 502, 504,
	5, 48, 25, 2, 503, 499, 3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 47, 3, 2,
	2, 2, 505, 521, 7, 7, 2, 2, 506, 517, 5, 50, 26, 2, 507, 509, 7, 127, 2,
	2, 508, 507, 3, 2, 2, 2, 508, 509, 3, 2, 2, 2, 509, 510, 3, 2, 2, 2, 510,
	512, 7, 4, 2, 2, 511, 513, 7, 127, 2, 2, 512, 511, 3, 2, 2, 2, 512, 513,
	3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 516, 5, 50, 26, 2, 515, 508, 3,
	2, 2, 2, 516, 519, 3, 2, 2, 2, 517, 515, 3, 2, 2, 2, 517, 518, 3, 2, 2,
	2, 518, 521, 3, 2, 2, 2, 519, 517, 3, 2, 2, 2, 520, 505, 3, 2, 2, 2, 520,
	506, 3, 2, 2, 2, 521, 526, 3, 2, 2, 2, 522, 524, 7, 127, 2, 2, 523, 522,
	3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 525, 3, 2, 2, 2, 525, 527, 5, 70,
	36, 2, 526, 523, 3, 2, 2, 2, 526, 527, 3, 2, 2, 2, 527, 49, 3, 2, 2, 2,
	528, 529, 5, 162, 82, 2, 529, 530, 7, 127, 2, 2, 530, 531, 7, 53, 2, 2,
	531, 532, 7, 127, 2, 2, 532, 534, 3, 2, 2, 2, 533, 528, 3, 2, 2, 2, 533,
	534, 3, 2, 2, 2, 534, 535, 3, 2, 2, 2, 535, 536, 5, 178, 90, 2, 536, 51,
	3, 2, 2, 2, 537, 542, 7, 63, 2, 2, 538, 540, 7, 127, 2, 2, 539, 538, 3,
	2, 2, 2, 539, 540, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2, 541, 543, 7, 64, 2,
	2, 542, 539, 3, 2, 2, 2, 542, 543, 3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544,
	545, 7, 127, 2, 2, 545, 550, 5, 56, 29, 2, 546, 548, 7, 127, 2, 2, 547,
	546, 3, 2, 2, 2, 547, 548, 3, 2, 2, 2, 548, 549, 3, 2, 2, 2, 549, 551,
	5, 70, 36, 2, 550, 547, 3, 2, 2, 2, 550, 551, 3, 2, 2, 2, 551, 53, 3, 2,
	2, 2, 552, 557, 7, 65, 2, 2, 553, 555, 7, 127, 2, 2, 554, 553, 3, 2, 2,
	2, 554, 555, 3, 2, 2, 2, 555, 556, 3, 2, 2, 2, 556, 558, 7, 64, 2, 2, 557,
	554, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 560,
	7, 127, 2, 2, 560, 561, 5, 56, 29, 2, 561, 55, 3, 2, 2, 2, 562, 565, 5,
	58, 30, 2, 563, 564, 7, 127, 2, 2, 564, 566, 5, 62, 32, 2, 565, 563, 3,
	2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 569, 3, 2, 2, 2, 567, 568, 7, 127,
	2, 2, 568, 570, 5, 64, 33, 2, 569, 567, 3, 2, 2, 2, 569, 570, 3, 2, 2,
	2, 570, 573, 3, 2, 2, 2, 571, 572, 7, 127, 2, 2, 572, 574, 5, 66, 34, 2,
	573, 571, 3, 2, 2, 2, 573, 574, 3, 2, 2, 2, 574, 57, 3, 2, 2, 2, 575, 586,
	7, 7, 2, 2, 576, 578, 7, 127, 2, 2, 577, 576, 3, 2, 2, 2, 577, 578, 3,
	2, 2, 2, 578, 579, 3, 2, 2, 2, 579, 581, 7, 4, 2, 2, 580, 582, 7, 127,
	2, 2, 581, 580, 3, 2, 2, 2, 581, 582, 3, 2, 2, 2, 582, 583, 3, 2, 2, 2,
	583, 585, 5, 60, 31, 2, 584, 577, 3, 2, 2, 2, 585, 588, 3, 2, 2, 2, 586,
	584, 3, 2, 2, 2, 586, 587, 3, 2, 2, 2, 587, 604, 3, 2, 2, 2, 588, 586,
	3, 2, 2, 2, 589, 600, 5, 60, 31, 2, 590, 592, 7, 127, 2, 2, 591, 590, 3,
	2, 2, 2, 591, 592, 3, 2, 2, 2, 592, 593, 3, 2, 2, 2, 593, 595, 7, 4, 2,
	2, 594, 596, 7, 127, 2, 2, 595, 594, 3, 2, 2, 2, 595, 596, 3, 2, 2, 2,
	596, 597, 3, 2, 2, 2, 597, 599, 5, 60, 31, 2, 598, 591, 3, 2, 2, 2, 599,
	602, 3, 2, 2, 2, 600, 598, 3, 2, 2, 2, 600, 601, 3, 2, 2, 2, 601, 604,
	3, 2, 2, 2, 602, 600, 3, 2, 2, 2, 603, 575, 3, 2, 2, 2, 603, 589, 3, 2,
	2, 2, 604, 59, 3, 2, 2, 2, 605, 606, 5, 106, 54, 2, 606, 607, 7, 127, 2,
	2, 607, 608, 7, 53, 2, 2, 608, 609, 7, 127, 2, 2, 609, 610, 5, 178, 90,
	2, 610, 613, 3, 2, 2, 2, 611, 613, 5, 106, 54, 2, 612, 605, 3, 2, 2, 2,
	612, 611, 3, 2, 2, 2, 613, 61, 3, 2, 2, 2, 614, 615, 7, 66, 2, 2, 615,
	616, 7, 127, 2, 2, 616, 617, 7, 67, 2, 2, 617, 618, 7, 127, 2, 2, 618,
	626, 5, 68, 35, 2, 619, 621, 7, 4, 2, 2, 620, 622, 7, 127, 2, 2, 621, 620,
	3, 2, 2, 2, 621, 622, 3, 2, 2, 2, 622, 623, 3, 2, 2, 2, 623, 625, 5, 68,
	35, 2, 624, 619, 3, 2, 2, 2, 625, 628, 3, 2, 2, 2, 626, 624, 3, 2, 2, 2,
	626, 627, 3, 2, 2, 2, 627, 63, 3, 2, 2, 2, 628, 626, 3, 2, 2, 2, 629, 630,
	7, 68, 2, 2, 630, 631, 7, 127, 2, 2, 631, 632, 5, 106, 54, 2, 632, 65,
	3, 2, 2, 2, 633, 634, 7, 69, 2, 2, 634, 635, 7, 127, 2, 2, 635, 636, 5,
	106, 54, 2, 636, 67, 3, 2, 2, 2, 637, 642, 5, 106, 54, 2, 638, 640, 7,
	127, 2, 2, 639, 638, 3, 2, 2, 2, 639, 640, 3, 2, 2, 2, 640, 641, 3, 2,
	2, 2, 641, 643, 9, 2, 2, 2, 642, 639, 3, 2, 2, 2, 642, 643, 3, 2, 2, 2,
	643, 69, 3, 2, 2, 2, 644, 645, 7, 74, 2, 2, 645, 646, 7, 127, 2, 2, 646,
	647, 5, 106, 54, 2, 647, 71, 3, 2, 2, 2, 648, 659, 5, 74, 38, 2, 649, 651,
	7, 127, 2, 2, 650, 649, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 652, 3,
	2, 2, 2, 652, 654, 7, 4, 2, 2, 653, 655, 7, 127, 2, 2, 654, 653, 3, 2,
	2, 2, 654, 655, 3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 658, 5, 74, 38,
	2, 657, 650, 3, 2, 2, 2, 658, 661, 3, 2, 2, 2, 659, 657, 3, 2, 2, 2, 659,
	660, 3, 2, 2, 2, 660, 73, 3, 2, 2, 2, 661, 659, 3, 2, 2, 2, 662, 664, 5,
	178, 90, 2, 663, 665, 7, 127, 2, 2, 664, 663, 3, 2, 2, 2, 664, 665, 3,
	2, 2, 2, 665, 666, 3, 2, 2, 2, 666, 668, 7, 5, 2, 2, 667, 669, 7, 127,
	2, 2, 668, 667, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669, 670, 3, 2, 2, 2,
	670, 671, 5, 76, 39, 2, 671, 674, 3, 2, 2, 2, 672, 674, 5, 76, 39, 2, 673,
	662, 3, 2, 2, 2, 673, 672, 3, 2, 2, 2, 674, 75, 3, 2, 2, 2, 675, 676, 5,
	78, 40, 2, 676, 77, 3, 2, 2, 2, 677, 684, 5, 80, 41, 2, 678, 680, 7, 127,
	2, 2, 679, 678, 3, 2, 2, 2, 679, 680, 3, 2, 2, 2, 680, 681, 3, 2, 2, 2,
	681, 683, 5, 82, 42, 2, 682, 679, 3, 2, 2, 2, 683, 686, 3, 2, 2, 2, 684,
	682, 3, 2, 2, 2, 684, 685, 3, 2, 2, 2, 685, 692, 3, 2, 2, 2, 686, 684,
	3, 2, 2, 2, 687, 688, 7, 8, 2, 2, 688, 689, 5, 78, 40, 2, 689, 690, 7,
	9, 2, 2, 690, 692, 3, 2, 2, 2, 691, 677, 3, 2, 2, 2, 691, 687, 3, 2, 2,
	2, 692, 79, 3, 2, 2, 2, 693, 695, 7, 8, 2, 2, 694, 696, 7, 127, 2, 2, 695,
	694, 3, 2, 2, 2, 695, 696, 3, 2, 2, 2, 696, 701, 3, 2, 2, 2, 697, 699,
	5, 178, 90, 2, 698, 700, 7, 127, 2, 2, 699, 698, 3, 2, 2, 2, 699, 700,
	3, 2, 2, 2, 700, 702, 3, 2, 2, 2, 701, 697, 3, 2, 2, 2, 701, 702, 3, 2,
	2, 2, 702, 707, 3, 2, 2, 2, 703, 705, 5, 92, 47, 2, 704, 706, 7, 127, 2,
	2, 705, 704, 3, 2, 2, 2, 705, 706, 3, 2, 2, 2, 706, 708, 3, 2, 2, 2, 707,
	703, 3, 2, 2, 2, 707, 708, 3, 2, 2, 2, 708, 713, 3, 2, 2, 2, 709, 711,
	5, 88, 45, 2, 710, 712, 7, 127, 2, 2, 711, 710, 3, 2, 2, 2, 711, 712, 3,
	2, 2, 2, 712, 714, 3, 2, 2, 2, 713, 709, 3, 2, 2, 2, 713, 714, 3, 2, 2,
	2, 714, 715, 3, 2, 2, 2, 715, 716, 7, 9, 2, 2, 716, 81, 3, 2, 2, 2, 717,
	719, 5, 84, 43, 2, 718, 720, 7, 127, 2, 2, 719, 718, 3, 2, 2, 2, 719, 720,
	3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721, 722, 5, 80, 41, 2, 722, 83, 3, 2,
	2, 2, 723, 725, 5, 200, 101, 2, 724, 726, 7, 127, 2, 2, 725, 724, 3, 2,
	2, 2, 725, 726, 3, 2, 2, 2, 726, 727, 3, 2, 2, 2, 727, 729, 5, 204, 103,
	2, 728, 730, 7, 127, 2, 2, 729, 728, 3, 2, 2, 2, 729, 730, 3, 2, 2, 2,
	730, 732, 3, 2, 2, 2, 731, 733, 5, 86, 44, 2, 732, 731, 3, 2, 2, 2, 732,
	733, 3, 2, 2, 2, 733, 735, 3, 2, 2, 2, 734, 736, 7, 127, 2, 2, 735, 734,
	3, 2, 2, 2, 735, 736, 3, 2, 2, 2, 736, 737, 3, 2, 2, 2, 737, 739, 5, 204,
	103, 2, 738, 740, 7, 127, 2, 2, 739, 738, 3, 2, 2, 2, 739, 740, 3, 2, 2,
	2, 740, 741, 3, 2, 2, 2, 741, 742, 5, 202, 102, 2, 742, 788, 3, 2, 2, 2,
	743, 745, 5, 200, 101, 2, 744, 746, 7, 127, 2, 2, 745, 744, 3, 2, 2, 2,
	745, 746, 3, 2, 2, 2, 746, 747, 3, 2, 2, 2, 747, 749, 5, 204, 103, 2, 748,
	750, 7, 127, 2, 2, 749, 748, 3, 2, 2, 2, 749, 750, 3, 2, 2, 2, 750, 752,
	3, 2, 2, 2, 751, 753, 5, 86, 44, 2, 752, 751, 3, 2, 2, 2, 752, 753, 3,
	2, 2, 2, 753, 755, 3, 2, 2, 2, 754, 756, 7, 127, 2, 2, 755, 754, 3, 2,
	2, 2, 755, 756, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757, 758, 5, 204, 103,
	2, 758, 788, 3, 2, 2, 2, 759, 761, 5, 204, 103, 2, 760, 762, 7, 127, 2,
	2, 761, 760, 3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 764, 3, 2, 2, 2, 763,
	765, 5, 86, 44, 2, 764, 763, 3, 2, 2, 2, 764, 765, 3, 2, 2, 2, 765, 767,
	3, 2, 2, 2, 766, 768, 7, 127, 2, 2, 767, 766, 3, 2, 2, 2, 767, 768, 3,
	2, 2, 2, 768, 769, 3, 2, 2, 2, 769, 771, 5, 204, 103, 2, 770, 772, 7, 127,
	2, 2, 771, 770, 3, 2, 2, 2, 771, 772, 3, 2, 2, 2, 772, 773, 3, 2, 2, 2,
	773, 774, 5, 202, 102, 2, 774, 788, 3, 2, 2, 2, 775, 777, 5, 204, 103,
	2, 776, 778, 7, 127, 2, 2, 777, 776, 3, 2, 2, 2, 777, 778, 3, 2, 2, 2,
	778, 780, 3, 2, 2, 2, 779, 781, 5, 86, 44, 2, 780, 779, 3, 2, 2, 2, 780,
	781, 3, 2, 2, 2, 781, 783, 3, 2, 2, 2, 782, 784, 7, 127, 2, 2, 783, 782,
	3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784, 785, 3, 2, 2, 2, 785, 786, 5, 204,
	103, 2, 786, 788, 3, 2, 2, 2, 787, 723, 3, 2, 2, 2, 787, 743, 3, 2, 2,
	2, 787, 759, 3, 2, 2, 2, 787, 775, 3, 2, 2, 2, 788, 85, 3, 2, 2, 2, 789,
	791, 7, 10, 2, 2, 790, 792, 7, 127, 2, 2, 791, 790, 3, 2, 2, 2, 791, 792,
	3, 2, 2, 2, 792, 797, 3, 2, 2, 2, 793, 795, 5, 178, 90, 2, 794, 796, 7,
	127, 2, 2, 795, 794, 3, 2, 2, 2, 795, 796, 3, 2, 2, 2, 796, 798, 3, 2,
	2, 2, 797, 793, 3, 2, 2, 2, 797, 798, 3, 2, 2, 2, 798, 803, 3, 2, 2, 2,
	799, 801, 5, 90, 46, 2, 800, 802, 7, 127, 2, 2, 801, 800, 3, 2, 2, 2, 801,
	802, 3, 2, 2, 2, 802, 804, 3, 2, 2, 2, 803, 799, 3, 2, 2, 2, 803, 804,
	3, 2, 2, 2, 804, 806, 3, 2, 2, 2, 805, 807, 5, 96, 49, 2, 806, 805, 3,
	2, 2, 2, 806, 807, 3, 2, 2, 2, 807, 812, 3, 2, 2, 2, 808, 810, 5, 88, 45,
	2, 809, 811, 7, 127, 2, 2, 810, 809, 3, 2, 2, 2, 810, 811, 3, 2, 2, 2,
	811, 813, 3, 2, 2, 2, 812, 808, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 813,
	814, 3, 2, 2, 2, 814, 815, 7, 11, 2, 2, 815, 87, 3, 2, 2, 2, 816, 819,
	5, 182, 92, 2, 817, 819, 5, 184, 93, 2, 818, 816, 3, 2, 2, 2, 818, 817,
	3, 2, 2, 2, 819, 89, 3, 2, 2, 2, 820, 822, 7, 12, 2, 2, 821, 823, 7, 127,
	2, 2, 822, 821, 3, 2, 2, 2, 822, 823, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2,
	824, 838, 5, 104, 53, 2, 825, 827, 7, 127, 2, 2, 826, 825, 3, 2, 2, 2,
	826, 827, 3, 2, 2, 2, 827, 828, 3, 2, 2, 2, 828, 830, 7, 13, 2, 2, 829,
	831, 7, 12, 2, 2, 830, 829, 3, 2, 2, 2, 830, 831, 3, 2, 2, 2, 831, 833,
	3, 2, 2, 2, 832, 834, 7, 127, 2, 2, 833, 832, 3, 2, 2, 2, 833, 834, 3,
	2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 837, 5, 104, 53, 2, 836, 826, 3, 2,
	2, 2, 837, 840, 3, 2, 2, 2, 838, 836, 3, 2, 2, 2, 838, 839, 3, 2, 2, 2,
	839, 91, 3, 2, 2, 2, 840, 838, 3, 2, 2, 2, 841, 848, 5, 94, 48, 2, 842,
	844, 7, 127, 2, 2, 843, 842, 3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 845,
	3, 2, 2, 2, 845, 847, 5, 94, 48, 2, 846, 843, 3, 2, 2, 2, 847, 850, 3,
	2, 2, 2, 848, 846, 3, 2, 2, 2, 848, 849, 3, 2, 2, 2, 849, 93, 3, 2, 2,
	2, 850, 848, 3, 2, 2, 2, 851, 853, 7, 12, 2, 2, 852, 854, 7, 127, 2, 2,
	853, 852, 3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 855, 3, 2, 2, 2, 855,
	856, 5, 102, 52, 2, 856, 95, 3, 2, 2, 2, 857, 859, 7, 7, 2, 2, 858, 860,
	7, 127, 2, 2, 859, 858, 3, 2, 2, 2, 859, 860, 3, 2, 2, 2, 860, 865, 3,
	2, 2, 2, 861, 863, 5, 98, 50, 2, 862, 864, 7, 127, 2, 2, 863, 862, 3, 2,
	2, 2, 863, 864, 3, 2, 2, 2, 864, 866, 3, 2, 2, 2, 865, 861, 3, 2, 2, 2,
	865, 866, 3, 2, 2, 2, 866, 877, 3, 2, 2, 2, 867, 869, 7, 14, 2, 2, 868,
	870, 7, 127, 2, 2, 869, 868, 3, 2, 2, 2, 869, 870, 3, 2, 2, 2, 870, 875,
	3, 2, 2, 2, 871, 873, 5, 100, 51, 2, 872, 874, 7, 127, 2, 2, 873, 872,
	3, 2, 2, 2, 873, 874, 3, 2, 2, 2, 874, 876, 3, 2, 2, 2, 875, 871, 3, 2,
	2, 2, 875, 876, 3, 2, 2, 2, 876, 878, 3, 2, 2, 2, 877, 867, 3, 2, 2, 2,
	877, 878, 3, 2, 2, 2, 878, 97, 3, 2, 2, 2, 879, 880, 5, 190, 96, 2, 880,
	99, 3, 2, 2, 2, 881, 882, 5, 190, 96, 2, 882, 101, 3, 2, 2, 2, 883, 884,
	5, 194, 98, 2, 884, 103, 3, 2, 2, 2, 885, 886, 5, 194, 98, 2, 886, 105,
	3, 2, 2, 2, 887, 888, 5, 108, 55, 2, 888, 107, 3, 2, 2, 2, 889, 896, 5,
	110, 56, 2, 890, 891, 7, 127, 2, 2, 891, 892, 7, 75, 2, 2, 892, 893, 7,
	127, 2, 2, 893, 895, 5, 110, 56, 2, 894, 890, 3, 2, 2, 2, 895, 898, 3,
	2, 2, 2, 896, 894, 3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 109, 3, 2, 2,
	2, 898, 896, 3, 2, 2, 2, 899, 906, 5, 112, 57, 2, 900, 901, 7, 127, 2,
	2, 901, 902, 7, 76, 2, 2, 902, 903, 7, 127, 2, 2, 903, 905, 5, 112, 57,
	2, 904, 900, 3, 2, 2, 2, 905, 908, 3, 2, 2, 2, 906, 904, 3, 2, 2, 2, 906,
	907, 3, 2, 2, 2, 907, 111, 3, 2, 2, 2, 908, 906, 3, 2, 2, 2, 909, 916,
	5, 114, 58, 2, 910, 911, 7, 127, 2, 2, 911, 912, 7, 77, 2, 2, 912, 913,
	7, 127, 2, 2, 913, 915, 5, 114, 58, 2, 914, 910, 3, 2, 2, 2, 915, 918,
	3, 2, 2, 2, 916, 914, 3, 2, 2, 2, 916, 917, 3, 2, 2, 2, 917, 113, 3, 2,
	2, 2, 918, 916, 3, 2, 2, 2, 919, 921, 7, 78, 2, 2, 920, 922, 7, 127, 2,
	2, 921, 920, 3, 2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 924, 3, 2, 2, 2, 923,
	919, 3, 2, 2, 2, 924, 927, 3, 2, 2, 2, 925, 923, 3, 2, 2, 2, 925, 926,
	3, 2, 2, 2, 926, 928, 3, 2, 2, 2, 927, 925, 3, 2, 2, 2, 928, 929, 5, 116,
	59, 2, 929, 115, 3, 2, 2, 2, 930, 937, 5, 118, 60, 2, 931, 933, 7, 127,
	2, 2, 932, 931, 3, 2, 2, 2, 932, 933, 3, 2, 2, 2, 933, 934, 3, 2, 2, 2,
	934, 936, 5, 144, 73, 2, 935, 932, 3, 2, 2, 2, 936, 939, 3, 2, 2, 2, 937,
	935, 3, 2, 2, 2, 937, 938, 3, 2, 2, 2, 938, 117, 3, 2, 2, 2, 939, 937,
	3, 2, 2, 2, 940, 959, 5, 120, 61, 2, 941, 943, 7, 127, 2, 2, 942, 941,
	3, 2, 2, 2, 942, 943, 3, 2, 2, 2, 943, 944, 3, 2, 2, 2, 944, 946, 7, 15,
	2, 2, 945, 947, 7, 127, 2, 2, 946, 945, 3, 2, 2, 2, 946, 947, 3, 2, 2,
	2, 947, 948, 3, 2, 2, 2, 948, 958, 5, 120, 61, 2, 949, 951, 7, 127, 2,
	2, 950, 949, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952,
	954, 7, 16, 2, 2, 953, 955, 7, 127, 2, 2, 954, 953, 3, 2, 2, 2, 954, 955,
	3, 2, 2, 2, 955, 956, 3, 2, 2, 2, 956, 958, 5, 120, 61, 2, 957, 942, 3,
	2, 2, 2, 957, 950, 3, 2, 2, 2, 958, 961, 3, 2, 2, 2, 959, 957, 3, 2, 2,
	2, 959, 960, 3, 2, 2, 2, 960, 119, 3, 2, 2, 2, 961, 959, 3, 2, 2, 2, 962,
	989, 5, 122, 62, 2, 963, 965, 7, 127, 2, 2, 964, 963, 3, 2, 2, 2, 964,
	965, 3, 2, 2, 2, 965, 966, 3, 2, 2, 2, 966, 968, 7, 7, 2, 2, 967, 969,
	7, 127, 2, 2, 968, 967, 3, 2, 2, 2, 968, 969, 3, 2, 2, 2, 969, 970, 3,
	2, 2, 2, 970, 988, 5, 122, 62, 2, 971, 973, 7, 127, 2, 2, 972, 971, 3,
	2, 2, 2, 972, 973, 3, 2, 2, 2, 973, 974, 3, 2, 2, 2, 974, 976, 7, 17, 2,
	2, 975, 977, 7, 127, 2, 2, 976, 975, 3, 2, 2, 2, 976, 977, 3, 2, 2, 2,
	977, 978, 3, 2, 2, 2, 978, 988, 5, 122, 62, 2, 979, 981, 7, 127, 2, 2,
	980, 979, 3, 2, 2, 2, 980, 981, 3, 2, 2, 2, 981, 982, 3, 2, 2, 2, 982,
	984, 7, 18, 2, 2, 983, 985, 7, 127, 2, 2, 984, 983, 3, 2, 2, 2, 984, 985,
	3, 2, 2, 2, 985, 986, 3, 2, 2, 2, 986, 988, 5, 122, 62, 2, 987, 964, 3,
	2, 2, 2, 987, 972, 3, 2, 2, 2, 987, 980, 3, 2, 2, 2, 988, 991, 3, 2, 2,
	2, 989, 987, 3, 2, 2, 2, 989, 990, 3, 2, 2, 2, 990, 121, 3, 2, 2, 2, 991,
	989, 3, 2, 2, 2, 992, 1003, 5, 124, 63, 2, 993, 995, 7, 127, 2, 2, 994,
	993, 3, 2, 2, 2, 994, 995, 3, 2, 2, 2, 995, 996, 3, 2, 2, 2, 996, 998,
	7, 19, 2, 2, 997, 999, 7, 127, 2, 2, 998, 997, 3, 2, 2, 2, 998, 999, 3,
	2, 2, 2, 999, 1000, 3, 2, 2, 2, 1000, 1002, 5, 124, 63, 2, 1001, 994, 3,
	2, 2, 2, 1002, 1005, 3, 2, 2, 2, 1003, 1001, 3, 2, 2, 2, 1003, 1004, 3,
	2, 2, 2, 1004, 123, 3, 2, 2, 2, 1005, 1003, 3, 2, 2, 2, 1006, 1008, 9,
	3, 2, 2, 1007, 1009, 7, 127, 2, 2, 1008, 1007, 3, 2, 2, 2, 1008, 1009,
	3, 2, 2, 2, 1009, 1011, 3, 2, 2, 2, 1010, 1006, 3, 2, 2, 2, 1011, 1014,
	3, 2, 2, 2, 1012, 1010, 3, 2, 2, 2, 1012, 1013, 3, 2, 2, 2, 1013, 1015,
	3, 2, 2, 2, 1014, 1012, 3, 2, 2, 2, 1015, 1016, 5, 126, 64, 2, 1016, 125,
	3, 2, 2, 2, 1017, 1023, 5, 134, 68, 2, 1018, 1022, 5, 130, 66, 2, 1019,
	1022, 5, 128, 65, 2, 1020, 1022, 5, 132, 67, 2, 1021, 1018, 3, 2, 2, 2,
	1021, 1019, 3, 2, 2, 2, 1021, 1020, 3, 2, 2, 2, 1022, 1025, 3, 2, 2, 2,
	1023, 1021, 3, 2, 2, 2, 1023, 1024, 3, 2, 2, 2, 1024, 127, 3, 2, 2, 2,
	1025, 1023, 3, 2, 2, 2, 1026, 1027, 7, 127, 2, 2, 1027, 1029, 7, 79, 2,
	2, 1028, 1030, 7, 127, 2, 2, 1029, 1028, 3, 2, 2, 2, 1029, 1030, 3, 2,
	2, 2, 1030, 1031, 3, 2, 2, 2, 1031, 1052, 5, 134, 68, 2, 1032, 1034, 7,
	127, 2, 2, 1033, 1032, 3, 2, 2, 2, 1033, 1034, 3, 2, 2, 2, 1034, 1035,
	3, 2, 2, 2, 1035, 1036, 7, 10, 2, 2, 1036, 1037, 5, 106, 54, 2, 1037, 1038,
	7, 11, 2, 2, 1038, 1052, 3, 2, 2, 2, 1039, 1041, 7, 127, 2, 2, 1040, 1039,
	3, 2, 2, 2, 1040, 1041, 3, 2, 2, 2, 1041, 1042, 3, 2, 2, 2, 1042, 1044,
	7, 10, 2, 2, 1043, 1045, 5, 106, 54, 2, 1044, 1043, 3, 2, 2, 2, 1044, 1045,
	3, 2, 2, 2, 1045, 1046, 3, 2, 2, 2, 1046, 1048, 7, 14, 2, 2, 1047, 1049,
	5, 106, 54, 2, 1048, 1047, 3, 2, 2, 2, 1048, 1049, 3, 2, 2, 2, 1049, 1050,
	3, 2, 2, 2, 1050, 1052, 7, 11, 2, 2, 1051, 1026, 3, 2, 2, 2, 1051, 1033,
	3, 2, 2, 2, 1051, 1040, 3, 2, 2, 2, 1052, 129, 3, 2, 2, 2, 1053, 1054,
	7, 127, 2, 2, 1054, 1055, 7, 80, 2, 2, 1055, 1056, 7, 127, 2, 2, 1056,
	1064, 7, 63, 2, 2, 1057, 1058, 7, 127, 2, 2, 1058, 1059, 7, 81, 2, 2, 1059,
	1060, 7, 127, 2, 2, 1060, 1064, 7, 63, 2, 2, 1061, 1062, 7, 127, 2, 2,
	1062, 1064, 7, 82, 2, 2, 1063, 1053, 3, 2, 2, 2, 1063, 1057, 3, 2, 2, 2,
	1063, 1061, 3, 2, 2, 2, 1064, 1066, 3, 2, 2, 2, 1065, 1067, 7, 127, 2,
	2, 1066, 1065, 3, 2, 2, 2, 1066, 1067, 3, 2, 2, 2, 1067, 1068, 3, 2, 2,
	2, 1068, 1069, 5, 134, 68, 2, 1069, 131, 3, 2, 2, 2, 1070, 1071, 7, 127,
	2, 2, 1071, 1072, 7, 83, 2, 2, 1072, 1073, 7, 127, 2, 2, 1073, 1081, 7,
	84, 2, 2, 1074, 1075, 7, 127, 2, 2, 1075, 1076, 7, 83, 2, 2, 1076, 1077,
	7, 127, 2, 2, 1077, 1078, 7, 78, 2, 2, 1078, 1079, 7, 127, 2, 2, 1079,
	1081, 7, 84, 2, 2, 1080, 1070, 3, 2, 2, 2, 1080, 1074, 3, 2, 2, 2, 1081,
	133, 3, 2, 2, 2, 1082, 1089, 5, 136, 69, 2, 1083, 1085, 7, 127, 2, 2, 1084,
	1083, 3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1086, 3, 2, 2, 2, 1086,
	1088, 5, 172, 87, 2, 1087, 1084, 3, 2, 2, 2, 1088, 1091, 3, 2, 2, 2, 1089,
	1087, 3, 2, 2, 2, 1089, 1090, 3, 2, 2, 2, 1090, 1096, 3, 2, 2, 2, 1091,
	1089, 3, 2, 2, 2, 1092, 1094, 7, 127, 2, 2, 1093, 1092, 3, 2, 2, 2, 1093,
	1094, 3, 2, 2, 2, 1094, 1095, 3, 2, 2, 2, 1095, 1097, 5, 92, 47, 2, 1096,
	1093, 3, 2, 2, 2, 1096, 1097, 3, 2, 2, 2, 1097, 135, 3, 2, 2, 2, 1098,
	1177, 5, 138, 70, 2, 1099, 1177, 5, 184, 93, 2, 1100, 1177, 5, 174, 88,
	2, 1101, 1103, 7, 85, 2, 2, 1102, 1104, 7, 127, 2, 2, 1103, 1102, 3, 2,
	2, 2, 1103, 1104, 3, 2, 2, 2, 1104, 1105, 3, 2, 2, 2, 1105, 1107, 7, 8,
	2, 2, 1106, 1108, 7, 127, 2, 2, 1107, 1106, 3, 2, 2, 2, 1107, 1108, 3,
	2, 2, 2, 1108, 1109, 3, 2, 2, 2, 1109, 1111, 7, 7, 2, 2, 1110, 1112, 7,
	127, 2, 2, 1111, 1110, 3, 2, 2, 2, 1111, 1112, 3, 2, 2, 2, 1112, 1113,
	3, 2, 2, 2, 1113, 1177, 7, 9, 2, 2, 1114, 1177, 5, 168, 85, 2, 1115, 1177,
	5, 170, 86, 2, 1116, 1118, 7, 49, 2, 2, 1117, 1119, 7, 127, 2, 2, 1118,
	1117, 3, 2, 2, 2, 1118, 1119, 3, 2, 2, 2, 1119, 1120, 3, 2, 2, 2, 1120,
	1122, 7, 8, 2, 2, 1121, 1123, 7, 127, 2, 2, 1122, 1121, 3, 2, 2, 2, 1122,
	1123, 3, 2, 2, 2, 1123, 1124, 3, 2, 2, 2, 1124, 1126, 5, 150, 76, 2, 1125,
	1127, 7, 127, 2, 2, 1126, 1125, 3, 2, 2, 2, 1126, 1127, 3, 2, 2, 2, 1127,
	1128, 3, 2, 2, 2, 1128, 1129, 7, 9, 2, 2, 1129, 1177, 3, 2, 2, 2, 1130,
	1132, 7, 86, 2, 2, 1131, 1133, 7, 127, 2, 2, 1132, 1131, 3, 2, 2, 2, 1132,
	1133, 3, 2, 2, 2, 1133, 1134, 3, 2, 2, 2, 1134, 1136, 7, 8, 2, 2, 1135,
	1137, 7, 127, 2, 2, 1136, 1135, 3, 2, 2, 2, 1136, 1137, 3, 2, 2, 2, 1137,
	1138, 3, 2, 2, 2, 1138, 1140, 5, 150, 76, 2, 1139, 1141, 7, 127, 2, 2,
	1140, 1139, 3, 2, 2, 2, 1140, 1141, 3, 2, 2, 2, 1141, 1142, 3, 2, 2, 2,
	1142, 1143, 7, 9, 2, 2, 1143, 1177, 3, 2, 2, 2, 1144, 1146, 7, 87, 2, 2,
	1145, 1147, 7, 127, 2, 2, 1146, 1145, 3, 2, 2, 2, 1146, 1147, 3, 2, 2,
	2, 1147, 1148, 3, 2, 2, 2, 1148, 1150, 7, 8, 2, 2, 1149, 1151, 7, 127,
	2, 2, 1150, 1149, 3, 2, 2, 2, 1150, 1151, 3, 2, 2, 2, 1151, 1152, 3, 2,
	2, 2, 1152, 1154, 5, 150, 76, 2, 1153, 1155, 7, 127, 2, 2, 1154, 1153,
	3, 2, 2, 2, 1154, 1155, 3, 2, 2, 2, 1155, 1156, 3, 2, 2, 2, 1156, 1157,
	7, 9, 2, 2, 1157, 1177, 3, 2, 2, 2, 1158, 1160, 7, 88, 2, 2, 1159, 1161,
	7, 127, 2, 2, 1160, 1159, 3, 2, 2, 2, 1160, 1161, 3, 2, 2, 2, 1161, 1162,
	3, 2, 2, 2, 1162, 1164, 7, 8, 2, 2, 1163, 1165, 7, 127, 2, 2, 1164, 1163,
	3, 2, 2, 2, 1164, 1165, 3, 2, 2, 2, 1165, 1166, 3, 2, 2, 2, 1166, 1168,
	5, 150, 76, 2, 1167, 1169, 7, 127, 2, 2, 1168, 1167, 3, 2, 2, 2, 1168,
	1169, 3, 2, 2, 2, 1169, 1170, 3, 2, 2, 2, 1170, 1171, 7, 9, 2, 2, 1171,
	1177, 3, 2, 2, 2, 1172, 1177, 5, 148, 75, 2, 1173, 1177, 5, 146, 74, 2,
	1174, 1177, 5, 154, 78, 2, 1175, 1177, 5, 178, 90, 2, 1176, 1098, 3, 2,
	2, 2, 1176, 1099, 3, 2, 2, 2, 1176, 1100, 3, 2, 2, 2, 1176, 1101, 3, 2,
	2, 2, 1176, 1114, 3, 2, 2, 2, 1176, 1115, 3, 2, 2, 2, 1176, 1116, 3, 2,
	2, 2, 1176, 1130, 3, 2, 2, 2, 1176, 1144, 3, 2, 2, 2, 1176, 1158, 3, 2,
	2, 2, 1176, 1172, 3, 2, 2, 2, 1176, 1173, 3, 2, 2, 2, 1176, 1174, 3, 2,
	2, 2, 1176, 1175, 3, 2, 2, 2, 1177, 137, 3, 2, 2, 2, 1178, 1185, 5, 180,
	91, 2, 1179, 1185, 7, 97, 2, 2, 1180, 1185, 5, 140, 71, 2, 1181, 1185,
	7, 84, 2, 2, 1182, 1185, 5, 182, 92, 2, 1183, 1185, 5, 142, 72, 2, 1184,
	1178, 3, 2, 2, 2, 1184, 1179, 3, 2, 2, 2, 1184, 1180, 3, 2, 2, 2, 1184,
	1181, 3, 2, 2, 2, 1184, 1182, 3, 2, 2, 2, 1184, 1183, 3, 2, 2, 2, 1185,
	139, 3, 2, 2, 2, 1186, 1187, 9, 4, 2, 2, 1187, 141, 3, 2, 2, 2, 1188, 1190,
	7, 10, 2, 2, 1189, 1191, 7, 127, 2, 2, 1190, 1189, 3, 2, 2, 2, 1190, 1191,
	3, 2, 2, 2, 1191, 1209, 3, 2, 2, 2, 1192, 1194, 5, 106, 54, 2, 1193, 1195,
	7, 127, 2, 2, 1194, 1193, 3, 2, 2, 2, 1194, 1195, 3, 2, 2, 2, 1195, 1206,
	3, 2, 2, 2, 1196, 1198, 7, 4, 2, 2, 1197, 1199, 7, 127, 2, 2, 1198, 1197,
	3, 2, 2, 2, 1198, 1199, 3, 2, 2, 2, 1199, 1200, 3, 2, 2, 2, 1200, 1202,
	5, 106, 54, 2, 1201, 1203, 7, 127, 2, 2, 1202, 1201, 3, 2, 2, 2, 1202,
	1203, 3, 2, 2, 2, 1203, 1205, 3, 2, 2, 2, 1204, 1196, 3, 2, 2, 2, 1205,
	1208, 3, 2, 2, 2, 1206, 1204, 3, 2, 2, 2, 1206, 1207, 3, 2, 2, 2, 1207,
	1210, 3, 2, 2, 2, 1208, 1206, 3, 2, 2, 2, 1209, 1192, 3, 2, 2, 2, 1209,
	1210, 3, 2, 2, 2, 1210, 1211, 3, 2, 2, 2, 1211, 1212, 7, 11, 2, 2, 1212,
	143, 3, 2, 2, 2, 1213, 1215, 7, 5, 2, 2, 1214, 1216, 7, 127, 2, 2, 1215,
	1214, 3, 2, 2, 2, 1215, 1216, 3, 2, 2, 2, 1216, 1217, 3, 2, 2, 2, 1217,
	1244, 5, 118, 60, 2, 1218, 1220, 7, 20, 2, 2, 1219, 1221, 7, 127, 2, 2,
	1220, 1219, 3, 2, 2, 2, 1220, 1221, 3, 2, 2, 2, 1221, 1222, 3, 2, 2, 2,
	1222, 1244, 5, 118, 60, 2, 1223, 1225, 7, 21, 2, 2, 1224, 1226, 7, 127,
	2, 2, 1225, 1224, 3, 2, 2, 2, 1225, 1226, 3, 2, 2, 2, 1226, 1227, 3, 2,
	2, 2, 1227, 1244, 5, 118, 60, 2, 1228, 1230, 7, 22, 2, 2, 1229, 1231, 7,
	127, 2, 2, 1230, 1229, 3, 2, 2, 2, 1230, 1231, 3, 2, 2, 2, 1231, 1232,
	3, 2, 2, 2, 1232, 1244, 5, 118, 60, 2, 1233, 1235, 7, 23, 2, 2, 1234, 1236,
	7, 127, 2, 2, 1235, 1234, 3, 2, 2, 2, 1235, 1236, 3, 2, 2, 2, 1236, 1237,
	3, 2, 2, 2, 1237, 1244, 5, 118, 60, 2, 1238, 1240, 7, 24, 2, 2, 1239, 1241,
	7, 127, 2, 2, 1240, 1239, 3, 2, 2, 2, 1240, 1241, 3, 2, 2, 2, 1241, 1242,
	3, 2, 2, 2, 1242, 1244, 5, 118, 60, 2, 1243, 1213, 3, 2, 2, 2, 1243, 1218,
	3, 2, 2, 2, 1243, 1223, 3, 2, 2, 2, 1243, 1228, 3, 2, 2, 2, 1243, 1233,
	3, 2, 2, 2, 1243, 1238, 3, 2, 2, 2, 1244, 145, 3, 2, 2, 2, 1245, 1247,
	7, 8, 2, 2, 1246, 1248, 7, 127, 2, 2, 1247, 1246, 3, 2, 2, 2, 1247, 1248,
	3, 2, 2, 2, 1248, 1249, 3, 2, 2, 2, 1249, 1251, 5, 106, 54, 2, 1250, 1252,
	7, 127, 2, 2, 1251, 1250, 3, 2, 2, 2, 1251, 1252, 3, 2, 2, 2, 1252, 1253,
	3, 2, 2, 2, 1253, 1254, 7, 9, 2, 2, 1254, 147, 3, 2, 2, 2, 1255, 1260,
	5, 80, 41, 2, 1256, 1258, 7, 127, 2, 2, 1257, 1256, 3, 2, 2, 2, 1257, 1258,
	3, 2, 2, 2, 1258, 1259, 3, 2, 2, 2, 1259, 1261, 5, 82, 42, 2, 1260, 1257,
	3, 2, 2, 2, 1261, 1262, 3, 2, 2, 2, 1262, 1260, 3, 2, 2, 2, 1262, 1263,
	3, 2, 2, 2, 1263, 149, 3, 2, 2, 2, 1264, 1269, 5, 152, 77, 2, 1265, 1267,
	7, 127, 2, 2, 1266, 1265, 3, 2, 2, 2, 1266, 1267, 3, 2, 2, 2, 1267, 1268,
	3, 2, 2, 2, 1268, 1270, 5, 70, 36, 2, 1269, 1266, 3, 2, 2, 2, 1269, 1270,
	3, 2, 2, 2, 1270, 151, 3, 2, 2, 2, 1271, 1272, 5, 178, 90, 2, 1272, 1273,
	7, 127, 2, 2, 1273, 1274, 7, 79, 2, 2, 1274, 1275, 7, 127, 2, 2, 1275,
	1276, 5, 106, 54, 2, 1276, 153, 3, 2, 2, 2, 1277, 1279, 5, 156, 79, 2,
	1278, 1280, 7, 127, 2, 2, 1279, 1278, 3, 2, 2, 2, 1279, 1280, 3, 2, 2,
	2, 1280, 1281, 3, 2, 2, 2, 1281, 1283, 7, 8, 2, 2, 1282, 1284, 7, 127,
	2, 2, 1283, 1282, 3, 2, 2, 2, 1283, 1284, 3, 2, 2, 2, 1284, 1289, 3, 2,
	2, 2, 1285, 1287, 7, 64, 2, 2, 1286, 1288, 7, 127, 2, 2, 1287, 1286, 3,
	2, 2, 2, 1287, 1288, 3, 2, 2, 2, 1288, 1290, 3, 2, 2, 2, 1289, 1285, 3,
	2, 2, 2, 1289, 1290, 3, 2, 2, 2, 1290, 1308, 3, 2, 2, 2, 1291, 1293, 5,
	106, 54, 2, 1292, 1294, 7, 127, 2, 2, 1293, 1292, 3, 2, 2, 2, 1293, 1294,
	3, 2, 2, 2, 1294, 1305, 3, 2, 2, 2, 1295, 1297, 7, 4, 2, 2, 1296, 1298,
	7, 127, 2, 2, 1297, 1296, 3, 2, 2, 2, 1297, 1298, 3, 2, 2, 2, 1298, 1299,
	3, 2, 2, 2, 1299, 1301, 5, 106, 54, 2, 1300, 1302, 7, 127, 2, 2, 1301,
	1300, 3, 2, 2, 2, 1301, 1302, 3, 2, 2, 2, 1302, 1304, 3, 2, 2, 2, 1303,
	1295, 3, 2, 2, 2, 1304, 1307, 3, 2, 2, 2, 1305, 1303, 3, 2, 2, 2, 1305,
	1306, 3, 2, 2, 2, 1306, 1309, 3, 2, 2, 2, 1307, 1305, 3, 2, 2, 2, 1308,
	1291, 3, 2, 2, 2, 1308, 1309, 3, 2, 2, 2, 1309, 1310, 3, 2, 2, 2, 1310,
	1311, 7, 9, 2, 2, 1311, 155, 3, 2, 2, 2, 1312, 1313, 5, 166, 84, 2, 1313,
	1314, 5, 198, 100, 2, 1314, 1317, 3, 2, 2, 2, 1315, 1317, 7, 91, 2, 2,
	1316, 1312, 3, 2, 2, 2, 1316, 1315, 3, 2, 2, 2, 1317, 157, 3, 2, 2, 2,
	1318, 1320, 5, 164, 83, 2, 1319, 1321, 7, 127, 2, 2, 1320, 1319, 3, 2,
	2, 2, 1320, 1321, 3, 2, 2, 2, 1321, 1322, 3, 2, 2, 2, 1322, 1324, 7, 8,
	2, 2, 1323, 1325, 7, 127, 2, 2, 1324, 1323, 3, 2, 2, 2, 1324, 1325, 3,
	2, 2, 2, 1325, 1343, 3, 2, 2, 2, 1326, 1328, 5, 106, 54, 2, 1327, 1329,
	7, 127, 2, 2, 1328, 1327, 3, 2, 2, 2, 1328, 1329, 3, 2, 2, 2, 1329, 1340,
	3, 2, 2, 2, 1330, 1332, 7, 4, 2, 2, 1331, 1333, 7, 127, 2, 2, 1332, 1331,
	3, 2, 2, 2, 1332, 1333, 3, 2, 2, 2, 1333, 1334, 3, 2, 2, 2, 1334, 1336,
	5, 106, 54, 2, 1335, 1337, 7, 127, 2, 2, 1336, 1335, 3, 2, 2, 2, 1336,
	1337, 3, 2, 2, 2, 1337, 1339, 3, 2, 2, 2, 1338, 1330, 3, 2, 2, 2, 1339,
	1342, 3, 2, 2, 2, 1340, 1338, 3, 2, 2, 2, 1340, 1341, 3, 2, 2, 2, 1341,
	1344, 3, 2, 2, 2, 1342, 1340, 3, 2, 2, 2, 1343, 1326, 3, 2, 2, 2, 1343,
	1344, 3, 2, 2, 2, 1344, 1345, 3, 2, 2, 2, 1345, 1346, 7, 9, 2, 2, 1346,
	159, 3, 2, 2, 2, 1347, 1348, 5, 164, 83, 2, 1348, 161, 3, 2, 2, 2, 1349,
	1350, 5, 198, 100, 2, 1350, 163, 3, 2, 2, 2, 1351, 1352, 5, 166, 84, 2,
	1352, 1353, 5, 198, 100, 2, 1353, 165, 3, 2, 2, 2, 1354, 1355, 5, 198,
	100, 2, 1355, 1356, 7, 25, 2, 2, 1356, 1358, 3, 2, 2, 2, 1357, 1354, 3,
	2, 2, 2, 1358, 1361, 3, 2, 2, 2, 1359, 1357, 3, 2, 2, 2, 1359, 1360, 3,
	2, 2, 2, 1360, 167, 3, 2, 2, 2, 1361, 1359, 3, 2, 2, 2, 1362, 1364, 7,
	10, 2, 2, 1363, 1365, 7, 127, 2, 2, 1364, 1363, 3, 2, 2, 2, 1364, 1365,
	3, 2, 2, 2, 1365, 1366, 3, 2, 2, 2, 1366, 1375, 5, 150, 76, 2, 1367, 1369,
	7, 127, 2, 2, 1368, 1367, 3, 2, 2, 2, 1368, 1369, 3, 2, 2, 2, 1369, 1370,
	3, 2, 2, 2, 1370, 1372, 7, 13, 2, 2, 1371, 1373, 7, 127, 2, 2, 1372, 1371,
	3, 2, 2, 2, 1372, 1373, 3, 2, 2, 2, 1373, 1374, 3, 2, 2, 2, 1374, 1376,
	5, 106, 54, 2, 1375, 1368, 3, 2, 2, 2, 1375, 1376, 3, 2, 2, 2, 1376, 1378,
	3, 2, 2, 2, 1377, 1379, 7, 127, 2, 2, 1378, 1377, 3, 2, 2, 2, 1378, 1379,
	3, 2, 2, 2, 1379, 1380, 3, 2, 2, 2, 1380, 1381, 7, 11, 2, 2, 1381, 169,
	3, 2, 2, 2, 1382, 1384, 7, 10, 2, 2, 1383, 1385, 7, 127, 2, 2, 1384, 1383,
	3, 2, 2, 2, 1384, 1385, 3, 2, 2, 2, 1385, 1394, 3, 2, 2, 2, 1386, 1388,
	5, 178, 90, 2, 1387, 1389, 7, 127, 2, 2, 1388, 1387, 3, 2, 2, 2, 1388,
	1389, 3, 2, 2, 2, 1389, 1390, 3, 2, 2, 2, 1390, 1392, 7, 5, 2, 2, 1391,
	1393, 7, 127, 2, 2, 1392, 1391, 3, 2, 2, 2, 1392, 1393, 3, 2, 2, 2, 1393,
	1395, 3, 2, 2, 2, 1394, 1386, 3, 2, 2, 2, 1394, 1395, 3, 2, 2, 2, 1395,
	1396, 3, 2, 2, 2, 1396, 1398, 5, 148, 75, 2, 1397, 1399, 7, 127, 2, 2,
	1398, 1397, 3, 2, 2, 2, 1398, 1399, 3, 2, 2, 2, 1399, 1408, 3, 2, 2, 2,
	1400, 1402, 7, 74, 2, 2, 1401, 1403, 7, 127, 2, 2, 1402, 1401, 3, 2, 2,
	2, 1402, 1403, 3, 2, 2, 2, 1403, 1404, 3, 2, 2, 2, 1404, 1406, 5, 106,
	54, 2, 1405, 1407, 7, 127, 2, 2, 1406, 1405, 3, 2, 2, 2, 1406, 1407, 3,
	2, 2, 2, 1407, 1409, 3, 2, 2, 2, 1408, 1400, 3, 2, 2, 2, 1408, 1409, 3,
	2, 2, 2, 1409, 1410, 3, 2, 2, 2, 1410, 1412, 7, 13, 2, 2, 1411, 1413, 7,
	127, 2, 2, 1412, 1411, 3, 2, 2, 2, 1412, 1413, 3, 2, 2, 2, 1413, 1414,
	3, 2, 2, 2, 1414, 1416, 5, 106, 54, 2, 1415, 1417, 7, 127, 2, 2, 1416,
	1415, 3, 2, 2, 2, 1416, 1417, 3, 2, 2, 2, 1417, 1418, 3, 2, 2, 2, 1418,
	1419, 7, 11, 2, 2, 1419, 171, 3, 2, 2, 2, 1420, 1422, 7, 25, 2, 2, 1421,
	1423, 7, 127, 2, 2, 1422, 1421, 3, 2, 2, 2, 1422, 1423, 3, 2, 2, 2, 1423,
	1424, 3, 2, 2, 2, 1424, 1425, 5, 188, 95, 2, 1425, 173, 3, 2, 2, 2, 1426,
	1431, 7, 92, 2, 2, 1427, 1429, 7, 127, 2, 2, 1428, 1427, 3, 2, 2, 2, 1428,
	1429, 3, 2, 2, 2, 1429, 1430, 3, 2, 2, 2, 1430, 1432, 5, 176, 89, 2, 1431,
	1428, 3, 2, 2, 2, 1432, 1433, 3, 2, 2, 2, 1433, 1431, 3, 2, 2, 2, 1433,
	1434, 3, 2, 2, 2, 1434, 1449, 3, 2, 2, 2, 1435, 1437, 7, 92, 2, 2, 1436,
	1438, 7, 127, 2, 2, 1437, 1436, 3, 2, 2, 2, 1437, 1438, 3, 2, 2, 2, 1438,
	1439, 3, 2, 2, 2, 1439, 1444, 5, 106, 54, 2, 1440, 1442, 7, 127, 2, 2,
	1441, 1440, 3, 2, 2, 2, 1441, 1442, 3, 2, 2, 2, 1442, 1443, 3, 2, 2, 2,
	1443, 1445, 5, 176, 89, 2, 1444, 1441, 3, 2, 2, 2, 1445, 1446, 3, 2, 2,
	2, 1446, 1444, 3, 2, 2, 2, 1446, 1447, 3, 2, 2, 2, 1447, 1449, 3, 2, 2,
	2, 1448, 1426, 3, 2, 2, 2, 1448, 1435, 3, 2, 2, 2, 1449, 1458, 3, 2, 2,
	2, 1450, 1452, 7, 127, 2, 2, 1451, 1450, 3, 2, 2, 2, 1451, 1452, 3, 2,
	2, 2, 1452, 1453, 3, 2, 2, 2, 1453, 1455, 7, 93, 2, 2, 1454, 1456, 7, 127,
	2, 2, 1455, 1454, 3, 2, 2, 2, 1455, 1456, 3, 2, 2, 2, 1456, 1457, 3, 2,
	2, 2, 1457, 1459, 5, 106, 54, 2, 1458, 1451, 3, 2, 2, 2, 1458, 1459, 3,
	2, 2, 2, 1459, 1461, 3, 2, 2, 2, 1460, 1462, 7, 127, 2, 2, 1461, 1460,
	3, 2, 2, 2, 1461, 1462, 3, 2, 2, 2, 1462, 1463, 3, 2, 2, 2, 1463, 1464,
	7, 94, 2, 2, 1464, 175, 3, 2, 2, 2, 1465, 1467, 7, 95, 2, 2, 1466, 1468,
	7, 127, 2, 2, 1467, 1466, 3, 2, 2, 2, 1467, 1468, 3, 2, 2, 2, 1468, 1469,
	3, 2, 2, 2, 1469, 1471, 5, 106, 54, 2, 1470, 1472, 7, 127, 2, 2, 1471,
	1470, 3, 2, 2, 2, 1471, 1472, 3, 2, 2, 2, 1472, 1473, 3, 2, 2, 2, 1473,
	1475, 7, 96, 2, 2, 1474, 1476, 7, 127, 2, 2, 1475, 1474, 3, 2, 2, 2, 1475,
	1476, 3, 2, 2, 2, 1476, 1477, 3, 2, 2, 2, 1477, 1478, 5, 106, 54, 2, 1478,
	177, 3, 2, 2, 2, 1479, 1480, 5, 198, 100, 2, 1480, 179, 3, 2, 2, 2, 1481,
	1484, 5, 192, 97, 2, 1482, 1484, 5, 190, 96, 2, 1483, 1481, 3, 2, 2, 2,
	1483, 1482, 3, 2, 2, 2, 1484, 181, 3, 2, 2, 2, 1485, 1487, 7, 26, 2, 2,
	1486, 1488, 7, 127, 2, 2, 1487, 1486, 3, 2, 2, 2, 1487, 1488, 3, 2, 2,
	2, 1488, 1522, 3, 2, 2, 2, 1489, 1491, 5, 188, 95, 2, 1490, 1492, 7, 127,
	2, 2, 1491, 1490, 3, 2, 2, 2, 1491, 1492, 3, 2, 2, 2, 1492, 1493, 3, 2,
	2, 2, 1493, 1495, 7, 12, 2, 2, 1494, 1496, 7, 127, 2, 2, 1495, 1494, 3,
	2, 2, 2, 1495, 1496, 3, 2, 2, 2, 1496, 1497, 3, 2, 2, 2, 1497, 1499, 5,
	106, 54, 2, 1498, 1500, 7, 127, 2, 2, 1499, 1498, 3, 2, 2, 2, 1499, 1500,
	3, 2, 2, 2, 1500, 1519, 3, 2, 2, 2, 1501, 1503, 7, 4, 2, 2, 1502, 1504,
	7, 127, 2, 2, 1503, 1502, 3, 2, 2, 2, 1503, 1504, 3, 2, 2, 2, 1504, 1505,
	3, 2, 2, 2, 1505, 1507, 5, 188, 95, 2, 1506, 1508, 7, 127, 2, 2, 1507,
	1506, 3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1509, 3, 2, 2, 2, 1509,
	1511, 7, 12, 2, 2, 1510, 1512, 7, 127, 2, 2, 1511, 1510, 3, 2, 2, 2, 1511,
	1512, 3, 2, 2, 2, 1512, 1513, 3, 2, 2, 2, 1513, 1515, 5, 106, 54, 2, 1514,
	1516, 7, 127, 2, 2, 1515, 1514, 3, 2, 2, 2, 1515, 1516, 3, 2, 2, 2, 1516,
	1518, 3, 2, 2, 2, 1517, 1501, 3, 2, 2, 2, 1518, 1521, 3, 2, 2, 2, 1519,
	1517, 3, 2, 2, 2, 1519, 1520, 3, 2, 2, 2, 1520, 1523, 3, 2, 2, 2, 1521,
	1519, 3, 2, 2, 2, 1522, 1489, 3, 2, 2, 2, 1522, 1523, 3, 2, 2, 2, 1523,
	1524, 3, 2, 2, 2, 1524, 1525, 7, 27, 2, 2, 1525, 183, 3, 2, 2, 2, 1526,
	1529, 7, 28, 2, 2, 1527, 1530, 5, 198, 100, 2, 1528, 1530, 7, 100, 2, 2,
	1529, 1527, 3, 2, 2, 2, 1529, 1528, 3, 2, 2, 2, 1530, 185, 3, 2, 2, 2,
	1531, 1536, 5, 136, 69, 2, 1532, 1534, 7, 127, 2, 2, 1533, 1532, 3, 2,
	2, 2, 1533, 1534, 3, 2, 2, 2, 1534, 1535, 3, 2, 2, 2, 1535, 1537, 5, 172,
	87, 2, 1536, 1533, 3, 2, 2, 2, 1537, 1538, 3, 2, 2, 2, 1538, 1536, 3, 2,
	2, 2, 1538, 1539, 3, 2, 2, 2, 1539, 187, 3, 2, 2, 2, 1540, 1541, 5, 194,
	98, 2, 1541, 189, 3, 2, 2, 2, 1542, 1543, 9, 5, 2, 2, 1543, 191, 3, 2,
	2, 2, 1544, 1545, 9, 6, 2, 2, 1545, 193, 3, 2, 2, 2, 1546, 1549, 5, 198,
	100, 2, 1547, 1549, 5, 196, 99, 2, 1548, 1546, 3, 2, 2, 2, 1548, 1547,
	3, 2, 2, 2, 1549, 195, 3, 2, 2, 2, 1550, 1551, 9, 7, 2, 2, 1551, 197, 3,
	2, 2, 2, 1552, 1553, 9, 8, 2, 2, 1553, 199, 3, 2, 2, 2, 1554, 1555, 9,
	9, 2, 2, 1555, 201, 3, 2, 2, 2, 1556, 1557, 9, 10, 2, 2, 1557, 203, 3,
	2, 2, 2, 1558, 1559, 9, 11, 2, 2, 1559, 205, 3, 2, 2, 2, 287, 207, 211,
	214, 217, 225, 229, 234, 241, 246, 249, 253, 257, 261, 267, 271, 276, 281,
	285, 288, 290, 295, 301, 305, 310, 314, 319, 326, 331, 335, 339, 343, 346,
	350, 360, 367, 380, 384, 390, 397, 402, 406, 412, 416, 422, 426, 432, 436,
	440, 444, 448, 452, 457, 464, 468, 473, 480, 486, 491, 497, 503, 508, 512,
	517, 520, 523, 526, 533, 539, 542, 547, 550, 554, 557, 565, 569, 573, 577,
	581, 586, 591, 595, 600, 603, 612, 621, 626, 639, 642, 650, 654, 659, 664,
	668, 673, 679, 684, 691, 695, 699, 701, 705, 707, 711, 713, 719, 725, 729,
	732, 735, 739, 745, 749, 752, 755, 761, 764, 767, 771, 777, 780, 783, 787,
	791, 795, 797, 801, 803, 806, 810, 812, 818, 822, 826, 830, 833, 838, 843,
	848, 853, 859, 863, 865, 869, 873, 875, 877, 896, 906, 916, 921, 925, 932,
	937, 942, 946, 950, 954, 957, 959, 964, 968, 972, 976, 980, 984, 987, 989,
	994, 998, 1003, 1008, 1012, 1021, 1023, 1029, 1033, 1040, 1044, 1048, 1051,
	1063, 1066, 1080, 1084, 1089, 1093, 1096, 1103, 1107, 1111, 1118, 1122,
	1126, 1132, 1136, 1140, 1146, 1150, 1154, 1160, 1164, 1168, 1176, 1184,
	1190, 1194, 1198, 1202, 1206, 1209, 1215, 1220, 1225, 1230, 1235, 1240,
	1243, 1247, 1251, 1257, 1262, 1266, 1269, 1279, 1283, 1287, 1289, 1293,
	1297, 1301, 1305, 1308, 1316, 1320, 1324, 1328, 1332, 1336, 1340, 1343,
	1359, 1364, 1368, 1372, 1375, 1378, 1384, 1388, 1392, 1394, 1398, 1402,
	1406, 1408, 1412, 1416, 1422, 1428, 1433, 1437, 1441, 1446, 1448, 1451,
	1455, 1458, 1461, 1467, 1471, 1475, 1483, 1487, 1491, 1495, 1499, 1503,
	1507, 1511, 1515, 1519, 1522, 1529, 1533, 1538, 1548,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "';'", "','", "'='", "'+='", "'*'", "'('", "')'", "'['", "']'", "':'",
	"'|'", "'..'", "'+'", "'-'", "'/'", "'%'", "'^'", "'<>'", "'<'", "'>'",
	"'<='", "'>='", "'.'", "'{'", "'}'", "'$'", "'\u27E8'", "'\u3008'", "'\uFE64'",
	"'\uFF1C'", "'\u27E9'", "'\u3009'", "'\uFE65'", "'\uFF1E'", "'\u00AD'",
	"'\u2010'", "'\u2011'", "'\u2012'", "'\u2013'", "'\u2014'", "'\u2015'",
	"'\u2212'", "'\uFE58'", "'\uFE63'", "'\uFF0D'", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"'0'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "UNION", "ALL", "OPTIONAL", "MATCH",
	"UNWIND", "AS", "MERGE", "ON", "CREATE", "SET", "DETACH", "DELETE", "REMOVE",
	"CALL", "YIELD", "WITH", "DISTINCT", "RETURN", "ORDER", "BY", "L_SKIP",
	"LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", "WHERE", "OR", "XOR",
	"AND", "NOT", "IN", "STARTS", "ENDS", "CONTAINS", "IS", "NULL", "COUNT",
	"ANY", "NONE", "SINGLE", "TRUE", "FALSE", "EXISTS", "CASE", "ELSE", "END",
	"WHEN", "THEN", "StringLiteral", "EscapedChar", "HexInteger", "DecimalInteger",
	"OctalInteger", "HexLetter", "HexDigit", "Digit", "NonZeroDigit", "NonZeroOctDigit",
	"OctDigit", "ZeroDigit", "ExponentDecimalReal", "RegularDecimalReal", "CONSTRAINT",
	"DO", "FOR", "REQUIRE", "UNIQUE", "MANDATORY", "SCALAR", "OF", "ADD", "DROP",
	"FILTER", "EXTRACT", "UnescapedSymbolicName", "IdentifierStart", "IdentifierPart",
	"EscapedSymbolicName", "SP", "WHITESPACE", "Comment",
}

var ruleNames = []string{
	"cypher", "stmt", "query", "regularQuery", "unionClause", "singleQuery",
	"singlePartQuery", "multiPartQuery", "multiPartQueryPartial", "updatingClause",
	"readingClause", "matchClause", "unwindClause", "mergeClause", "mergeAction",
	"createClause", "setClause", "setItem", "deleteClause", "removeClause",
	"removeItem", "inQueryCall", "standaloneCall", "yieldItems", "yieldItem",
	"withClause", "returnClause", "returnBody", "returnItems", "returnItem",
	"orderClause", "skipClause", "limitClause", "sortItem", "whereClause",
	"pattern", "patternPart", "anonymousPatternPart", "patternElement", "nodePattern",
	"patternElementChain", "relationshipPattern", "relationshipDetail", "properties",
	"relationshipTypes", "nodeLabels", "nodeLabel", "rangeLiteral", "minHops",
	"maxHops", "labelName", "relTypeName", "expr", "orExpr", "xorExpr", "andExpr",
	"notExpr", "comparisonExpr", "addOrSubtractExpr", "multiplyDivideModuloExpr",
	"powerOfExpr", "unaryAddOrSubtractExpr", "stringListNullOperatorExpr",
	"listOperatorExpr", "stringOperatorExpr", "nullOperatorExpr", "propertyOrLabelsExpr",
	"atom", "literal", "booleanLiteral", "listLiteral", "partialComparisonExpr",
	"parenthesizedExpr", "relationshipsPattern", "filterExpr", "idInColl",
	"functionInvocation", "functionName", "explicitProcedureInvocation", "implicitProcedureInvocation",
	"procedureResultField", "procedureName", "namespace", "listComprehension",
	"patternComprehension", "propertyLookup", "caseExpr", "caseAlternatives",
	"variable", "numberLiteral", "mapLiteral", "parameter", "propertyExpr",
	"propertyKeyName", "integerLiteral", "doubleLiteral", "schemaName", "reservedWord",
	"symbolicName", "leftArrowHead", "rightArrowHead", "dash",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type CypherParser struct {
	*antlr.BaseParser
}

func NewCypherParser(input antlr.TokenStream) *CypherParser {
	this := new(CypherParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Cypher.g4"

	return this
}

// CypherParser tokens.
const (
	CypherParserEOF                   = antlr.TokenEOF
	CypherParserT__0                  = 1
	CypherParserT__1                  = 2
	CypherParserT__2                  = 3
	CypherParserT__3                  = 4
	CypherParserT__4                  = 5
	CypherParserT__5                  = 6
	CypherParserT__6                  = 7
	CypherParserT__7                  = 8
	CypherParserT__8                  = 9
	CypherParserT__9                  = 10
	CypherParserT__10                 = 11
	CypherParserT__11                 = 12
	CypherParserT__12                 = 13
	CypherParserT__13                 = 14
	CypherParserT__14                 = 15
	CypherParserT__15                 = 16
	CypherParserT__16                 = 17
	CypherParserT__17                 = 18
	CypherParserT__18                 = 19
	CypherParserT__19                 = 20
	CypherParserT__20                 = 21
	CypherParserT__21                 = 22
	CypherParserT__22                 = 23
	CypherParserT__23                 = 24
	CypherParserT__24                 = 25
	CypherParserT__25                 = 26
	CypherParserT__26                 = 27
	CypherParserT__27                 = 28
	CypherParserT__28                 = 29
	CypherParserT__29                 = 30
	CypherParserT__30                 = 31
	CypherParserT__31                 = 32
	CypherParserT__32                 = 33
	CypherParserT__33                 = 34
	CypherParserT__34                 = 35
	CypherParserT__35                 = 36
	CypherParserT__36                 = 37
	CypherParserT__37                 = 38
	CypherParserT__38                 = 39
	CypherParserT__39                 = 40
	CypherParserT__40                 = 41
	CypherParserT__41                 = 42
	CypherParserT__42                 = 43
	CypherParserT__43                 = 44
	CypherParserT__44                 = 45
	CypherParserUNION                 = 46
	CypherParserALL                   = 47
	CypherParserOPTIONAL              = 48
	CypherParserMATCH                 = 49
	CypherParserUNWIND                = 50
	CypherParserAS                    = 51
	CypherParserMERGE                 = 52
	CypherParserON                    = 53
	CypherParserCREATE                = 54
	CypherParserSET                   = 55
	CypherParserDETACH                = 56
	CypherParserDELETE                = 57
	CypherParserREMOVE                = 58
	CypherParserCALL                  = 59
	CypherParserYIELD                 = 60
	CypherParserWITH                  = 61
	CypherParserDISTINCT              = 62
	CypherParserRETURN                = 63
	CypherParserORDER                 = 64
	CypherParserBY                    = 65
	CypherParserL_SKIP                = 66
	CypherParserLIMIT                 = 67
	CypherParserASCENDING             = 68
	CypherParserASC                   = 69
	CypherParserDESCENDING            = 70
	CypherParserDESC                  = 71
	CypherParserWHERE                 = 72
	CypherParserOR                    = 73
	CypherParserXOR                   = 74
	CypherParserAND                   = 75
	CypherParserNOT                   = 76
	CypherParserIN                    = 77
	CypherParserSTARTS                = 78
	CypherParserENDS                  = 79
	CypherParserCONTAINS              = 80
	CypherParserIS                    = 81
	CypherParserNULL                  = 82
	CypherParserCOUNT                 = 83
	CypherParserANY                   = 84
	CypherParserNONE                  = 85
	CypherParserSINGLE                = 86
	CypherParserTRUE                  = 87
	CypherParserFALSE                 = 88
	CypherParserEXISTS                = 89
	CypherParserCASE                  = 90
	CypherParserELSE                  = 91
	CypherParserEND                   = 92
	CypherParserWHEN                  = 93
	CypherParserTHEN                  = 94
	CypherParserStringLiteral         = 95
	CypherParserEscapedChar           = 96
	CypherParserHexInteger            = 97
	CypherParserDecimalInteger        = 98
	CypherParserOctalInteger          = 99
	CypherParserHexLetter             = 100
	CypherParserHexDigit              = 101
	CypherParserDigit                 = 102
	CypherParserNonZeroDigit          = 103
	CypherParserNonZeroOctDigit       = 104
	CypherParserOctDigit              = 105
	CypherParserZeroDigit             = 106
	CypherParserExponentDecimalReal   = 107
	CypherParserRegularDecimalReal    = 108
	CypherParserCONSTRAINT            = 109
	CypherParserDO                    = 110
	CypherParserFOR                   = 111
	CypherParserREQUIRE               = 112
	CypherParserUNIQUE                = 113
	CypherParserMANDATORY             = 114
	CypherParserSCALAR                = 115
	CypherParserOF                    = 116
	CypherParserADD                   = 117
	CypherParserDROP                  = 118
	CypherParserFILTER                = 119
	CypherParserEXTRACT               = 120
	CypherParserUnescapedSymbolicName = 121
	CypherParserIdentifierStart       = 122
	CypherParserIdentifierPart        = 123
	CypherParserEscapedSymbolicName   = 124
	CypherParserSP                    = 125
	CypherParserWHITESPACE            = 126
	CypherParserComment               = 127
)

// CypherParser rules.
const (
	CypherParserRULE_cypher                      = 0
	CypherParserRULE_stmt                        = 1
	CypherParserRULE_query                       = 2
	CypherParserRULE_regularQuery                = 3
	CypherParserRULE_unionClause                 = 4
	CypherParserRULE_singleQuery                 = 5
	CypherParserRULE_singlePartQuery             = 6
	CypherParserRULE_multiPartQuery              = 7
	CypherParserRULE_multiPartQueryPartial       = 8
	CypherParserRULE_updatingClause              = 9
	CypherParserRULE_readingClause               = 10
	CypherParserRULE_matchClause                 = 11
	CypherParserRULE_unwindClause                = 12
	CypherParserRULE_mergeClause                 = 13
	CypherParserRULE_mergeAction                 = 14
	CypherParserRULE_createClause                = 15
	CypherParserRULE_setClause                   = 16
	CypherParserRULE_setItem                     = 17
	CypherParserRULE_deleteClause                = 18
	CypherParserRULE_removeClause                = 19
	CypherParserRULE_removeItem                  = 20
	CypherParserRULE_inQueryCall                 = 21
	CypherParserRULE_standaloneCall              = 22
	CypherParserRULE_yieldItems                  = 23
	CypherParserRULE_yieldItem                   = 24
	CypherParserRULE_withClause                  = 25
	CypherParserRULE_returnClause                = 26
	CypherParserRULE_returnBody                  = 27
	CypherParserRULE_returnItems                 = 28
	CypherParserRULE_returnItem                  = 29
	CypherParserRULE_orderClause                 = 30
	CypherParserRULE_skipClause                  = 31
	CypherParserRULE_limitClause                 = 32
	CypherParserRULE_sortItem                    = 33
	CypherParserRULE_whereClause                 = 34
	CypherParserRULE_pattern                     = 35
	CypherParserRULE_patternPart                 = 36
	CypherParserRULE_anonymousPatternPart        = 37
	CypherParserRULE_patternElement              = 38
	CypherParserRULE_nodePattern                 = 39
	CypherParserRULE_patternElementChain         = 40
	CypherParserRULE_relationshipPattern         = 41
	CypherParserRULE_relationshipDetail          = 42
	CypherParserRULE_properties                  = 43
	CypherParserRULE_relationshipTypes           = 44
	CypherParserRULE_nodeLabels                  = 45
	CypherParserRULE_nodeLabel                   = 46
	CypherParserRULE_rangeLiteral                = 47
	CypherParserRULE_minHops                     = 48
	CypherParserRULE_maxHops                     = 49
	CypherParserRULE_labelName                   = 50
	CypherParserRULE_relTypeName                 = 51
	CypherParserRULE_expr                        = 52
	CypherParserRULE_orExpr                      = 53
	CypherParserRULE_xorExpr                     = 54
	CypherParserRULE_andExpr                     = 55
	CypherParserRULE_notExpr                     = 56
	CypherParserRULE_comparisonExpr              = 57
	CypherParserRULE_addOrSubtractExpr           = 58
	CypherParserRULE_multiplyDivideModuloExpr    = 59
	CypherParserRULE_powerOfExpr                 = 60
	CypherParserRULE_unaryAddOrSubtractExpr      = 61
	CypherParserRULE_stringListNullOperatorExpr  = 62
	CypherParserRULE_listOperatorExpr            = 63
	CypherParserRULE_stringOperatorExpr          = 64
	CypherParserRULE_nullOperatorExpr            = 65
	CypherParserRULE_propertyOrLabelsExpr        = 66
	CypherParserRULE_atom                        = 67
	CypherParserRULE_literal                     = 68
	CypherParserRULE_booleanLiteral              = 69
	CypherParserRULE_listLiteral                 = 70
	CypherParserRULE_partialComparisonExpr       = 71
	CypherParserRULE_parenthesizedExpr           = 72
	CypherParserRULE_relationshipsPattern        = 73
	CypherParserRULE_filterExpr                  = 74
	CypherParserRULE_idInColl                    = 75
	CypherParserRULE_functionInvocation          = 76
	CypherParserRULE_functionName                = 77
	CypherParserRULE_explicitProcedureInvocation = 78
	CypherParserRULE_implicitProcedureInvocation = 79
	CypherParserRULE_procedureResultField        = 80
	CypherParserRULE_procedureName               = 81
	CypherParserRULE_namespace                   = 82
	CypherParserRULE_listComprehension           = 83
	CypherParserRULE_patternComprehension        = 84
	CypherParserRULE_propertyLookup              = 85
	CypherParserRULE_caseExpr                    = 86
	CypherParserRULE_caseAlternatives            = 87
	CypherParserRULE_variable                    = 88
	CypherParserRULE_numberLiteral               = 89
	CypherParserRULE_mapLiteral                  = 90
	CypherParserRULE_parameter                   = 91
	CypherParserRULE_propertyExpr                = 92
	CypherParserRULE_propertyKeyName             = 93
	CypherParserRULE_integerLiteral              = 94
	CypherParserRULE_doubleLiteral               = 95
	CypherParserRULE_schemaName                  = 96
	CypherParserRULE_reservedWord                = 97
	CypherParserRULE_symbolicName                = 98
	CypherParserRULE_leftArrowHead               = 99
	CypherParserRULE_rightArrowHead              = 100
	CypherParserRULE_dash                        = 101
)

// ICypherContext is an interface to support dynamic dispatch.
type ICypherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherContext differentiates from other interfaces.
	IsCypherContext()
}

type CypherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherContext() *CypherContext {
	var p = new(CypherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypher
	return p
}

func (*CypherContext) IsCypherContext() {}

func NewCypherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherContext {
	var p = new(CypherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypher

	return p
}

func (s *CypherContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherContext) Stmt() IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *CypherContext) EOF() antlr.TerminalNode {
	return s.GetToken(CypherParserEOF, 0)
}

func (s *CypherContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CypherContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CypherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitCypher(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Cypher() (localctx ICypherContext) {
	localctx = NewCypherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CypherParserRULE_cypher)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(204)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(207)
		p.Stmt()
	}
	p.SetState(212)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		p.SetState(209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(208)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(211)
			p.Match(CypherParserT__0)
		}

	}
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(214)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(217)
		p.Match(CypherParserEOF)
	}

	return localctx
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CypherParserRULE_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.Query()
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) RegularQuery() IRegularQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularQueryContext)
}

func (s *QueryContext) StandaloneCall() IStandaloneCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandaloneCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandaloneCallContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CypherParserRULE_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(221)
			p.RegularQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(222)
			p.StandaloneCall()
		}

	}

	return localctx
}

// IRegularQueryContext is an interface to support dynamic dispatch.
type IRegularQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegularQueryContext differentiates from other interfaces.
	IsRegularQueryContext()
}

type RegularQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularQueryContext() *RegularQueryContext {
	var p = new(RegularQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_regularQuery
	return p
}

func (*RegularQueryContext) IsRegularQueryContext() {}

func NewRegularQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularQueryContext {
	var p = new(RegularQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_regularQuery

	return p
}

func (s *RegularQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularQueryContext) SingleQuery() ISingleQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleQueryContext)
}

func (s *RegularQueryContext) AllUnionClause() []IUnionClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionClauseContext)(nil)).Elem())
	var tst = make([]IUnionClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionClauseContext)
		}
	}

	return tst
}

func (s *RegularQueryContext) UnionClause(i int) IUnionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionClauseContext)
}

func (s *RegularQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RegularQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RegularQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRegularQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RegularQuery() (localctx IRegularQueryContext) {
	localctx = NewRegularQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CypherParserRULE_regularQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(225)
		p.SingleQuery()
	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(227)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(226)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(229)
				p.UnionClause()
			}

		}
		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// IUnionClauseContext is an interface to support dynamic dispatch.
type IUnionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionClauseContext differentiates from other interfaces.
	IsUnionClauseContext()
}

type UnionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionClauseContext() *UnionClauseContext {
	var p = new(UnionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_unionClause
	return p
}

func (*UnionClauseContext) IsUnionClauseContext() {}

func NewUnionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionClauseContext {
	var p = new(UnionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unionClause

	return p
}

func (s *UnionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionClauseContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *UnionClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnionClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnionClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *UnionClauseContext) SingleQuery() ISingleQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleQueryContext)
}

func (s *UnionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitUnionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) UnionClause() (localctx IUnionClauseContext) {
	localctx = NewUnionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CypherParserRULE_unionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(247)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(235)
			p.Match(CypherParserUNION)
		}
		{
			p.SetState(236)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(237)
			p.Match(CypherParserALL)
		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(238)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(241)
			p.SingleQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(242)
			p.Match(CypherParserUNION)
		}
		p.SetState(244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(243)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(246)
			p.SingleQuery()
		}

	}

	return localctx
}

// ISingleQueryContext is an interface to support dynamic dispatch.
type ISingleQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleQueryContext differentiates from other interfaces.
	IsSingleQueryContext()
}

type SingleQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQueryContext() *SingleQueryContext {
	var p = new(SingleQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_singleQuery
	return p
}

func (*SingleQueryContext) IsSingleQueryContext() {}

func NewSingleQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQueryContext {
	var p = new(SingleQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singleQuery

	return p
}

func (s *SingleQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQueryContext) SinglePartQuery() ISinglePartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISinglePartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISinglePartQueryContext)
}

func (s *SingleQueryContext) MultiPartQuery() IMultiPartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiPartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiPartQueryContext)
}

func (s *SingleQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitSingleQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SingleQuery() (localctx ISingleQueryContext) {
	localctx = NewSingleQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CypherParserRULE_singleQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(249)
			p.SinglePartQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(250)
			p.MultiPartQuery()
		}

	}

	return localctx
}

// ISinglePartQueryContext is an interface to support dynamic dispatch.
type ISinglePartQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSinglePartQueryContext differentiates from other interfaces.
	IsSinglePartQueryContext()
}

type SinglePartQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySinglePartQueryContext() *SinglePartQueryContext {
	var p = new(SinglePartQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_singlePartQuery
	return p
}

func (*SinglePartQueryContext) IsSinglePartQueryContext() {}

func NewSinglePartQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SinglePartQueryContext {
	var p = new(SinglePartQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singlePartQuery

	return p
}

func (s *SinglePartQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SinglePartQueryContext) ReturnClause() IReturnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnClauseContext)
}

func (s *SinglePartQueryContext) AllReadingClause() []IReadingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReadingClauseContext)(nil)).Elem())
	var tst = make([]IReadingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReadingClauseContext)
		}
	}

	return tst
}

func (s *SinglePartQueryContext) ReadingClause(i int) IReadingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReadingClauseContext)
}

func (s *SinglePartQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SinglePartQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SinglePartQueryContext) AllUpdatingClause() []IUpdatingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem())
	var tst = make([]IUpdatingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUpdatingClauseContext)
		}
	}

	return tst
}

func (s *SinglePartQueryContext) UpdatingClause(i int) IUpdatingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUpdatingClauseContext)
}

func (s *SinglePartQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SinglePartQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SinglePartQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitSinglePartQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SinglePartQuery() (localctx ISinglePartQueryContext) {
	localctx = NewSinglePartQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CypherParserRULE_singlePartQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(288)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(CypherParserOPTIONAL-48))|(1<<(CypherParserMATCH-48))|(1<<(CypherParserUNWIND-48))|(1<<(CypherParserCALL-48)))) != 0 {
			{
				p.SetState(253)
				p.ReadingClause()
			}
			p.SetState(255)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(254)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(261)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(262)
			p.ReturnClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(CypherParserOPTIONAL-48))|(1<<(CypherParserMATCH-48))|(1<<(CypherParserUNWIND-48))|(1<<(CypherParserCALL-48)))) != 0 {
			{
				p.SetState(263)
				p.ReadingClause()
			}
			p.SetState(265)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(264)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(271)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(272)
			p.UpdatingClause()
		}
		p.SetState(279)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(274)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(273)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(276)
					p.UpdatingClause()
				}

			}
			p.SetState(281)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			p.SetState(283)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(282)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(285)
				p.ReturnClause()
			}

		}

	}

	return localctx
}

// IMultiPartQueryContext is an interface to support dynamic dispatch.
type IMultiPartQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiPartQueryContext differentiates from other interfaces.
	IsMultiPartQueryContext()
}

type MultiPartQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiPartQueryContext() *MultiPartQueryContext {
	var p = new(MultiPartQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_multiPartQuery
	return p
}

func (*MultiPartQueryContext) IsMultiPartQueryContext() {}

func NewMultiPartQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiPartQueryContext {
	var p = new(MultiPartQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multiPartQuery

	return p
}

func (s *MultiPartQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiPartQueryContext) SinglePartQuery() ISinglePartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISinglePartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISinglePartQueryContext)
}

func (s *MultiPartQueryContext) AllMultiPartQueryPartial() []IMultiPartQueryPartialContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiPartQueryPartialContext)(nil)).Elem())
	var tst = make([]IMultiPartQueryPartialContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiPartQueryPartialContext)
		}
	}

	return tst
}

func (s *MultiPartQueryContext) MultiPartQueryPartial(i int) IMultiPartQueryPartialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiPartQueryPartialContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiPartQueryPartialContext)
}

func (s *MultiPartQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiPartQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiPartQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMultiPartQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MultiPartQuery() (localctx IMultiPartQueryContext) {
	localctx = NewMultiPartQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CypherParserRULE_multiPartQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(290)
				p.MultiPartQueryPartial()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
	}
	{
		p.SetState(295)
		p.SinglePartQuery()
	}

	return localctx
}

// IMultiPartQueryPartialContext is an interface to support dynamic dispatch.
type IMultiPartQueryPartialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiPartQueryPartialContext differentiates from other interfaces.
	IsMultiPartQueryPartialContext()
}

type MultiPartQueryPartialContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiPartQueryPartialContext() *MultiPartQueryPartialContext {
	var p = new(MultiPartQueryPartialContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_multiPartQueryPartial
	return p
}

func (*MultiPartQueryPartialContext) IsMultiPartQueryPartialContext() {}

func NewMultiPartQueryPartialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiPartQueryPartialContext {
	var p = new(MultiPartQueryPartialContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multiPartQueryPartial

	return p
}

func (s *MultiPartQueryPartialContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiPartQueryPartialContext) WithClause() IWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *MultiPartQueryPartialContext) AllReadingClause() []IReadingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReadingClauseContext)(nil)).Elem())
	var tst = make([]IReadingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReadingClauseContext)
		}
	}

	return tst
}

func (s *MultiPartQueryPartialContext) ReadingClause(i int) IReadingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReadingClauseContext)
}

func (s *MultiPartQueryPartialContext) AllUpdatingClause() []IUpdatingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem())
	var tst = make([]IUpdatingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUpdatingClauseContext)
		}
	}

	return tst
}

func (s *MultiPartQueryPartialContext) UpdatingClause(i int) IUpdatingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUpdatingClauseContext)
}

func (s *MultiPartQueryPartialContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MultiPartQueryPartialContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MultiPartQueryPartialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiPartQueryPartialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiPartQueryPartialContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMultiPartQueryPartial(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MultiPartQueryPartial() (localctx IMultiPartQueryPartialContext) {
	localctx = NewMultiPartQueryPartialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CypherParserRULE_multiPartQueryPartial)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(CypherParserOPTIONAL-48))|(1<<(CypherParserMATCH-48))|(1<<(CypherParserUNWIND-48))|(1<<(CypherParserCALL-48)))) != 0 {
		{
			p.SetState(297)
			p.ReadingClause()
		}
		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(298)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(305)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(CypherParserMERGE-52))|(1<<(CypherParserCREATE-52))|(1<<(CypherParserSET-52))|(1<<(CypherParserDETACH-52))|(1<<(CypherParserDELETE-52))|(1<<(CypherParserREMOVE-52)))) != 0 {
		{
			p.SetState(306)
			p.UpdatingClause()
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(307)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(315)
		p.WithClause()
	}
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(316)
			p.Match(CypherParserSP)
		}

	}

	return localctx
}

// IUpdatingClauseContext is an interface to support dynamic dispatch.
type IUpdatingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdatingClauseContext differentiates from other interfaces.
	IsUpdatingClauseContext()
}

type UpdatingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatingClauseContext() *UpdatingClauseContext {
	var p = new(UpdatingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_updatingClause
	return p
}

func (*UpdatingClauseContext) IsUpdatingClauseContext() {}

func NewUpdatingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatingClauseContext {
	var p = new(UpdatingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_updatingClause

	return p
}

func (s *UpdatingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatingClauseContext) CreateClause() ICreateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateClauseContext)
}

func (s *UpdatingClauseContext) MergeClause() IMergeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeClauseContext)
}

func (s *UpdatingClauseContext) DeleteClause() IDeleteClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteClauseContext)
}

func (s *UpdatingClauseContext) SetClause() ISetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetClauseContext)
}

func (s *UpdatingClauseContext) RemoveClause() IRemoveClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemoveClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRemoveClauseContext)
}

func (s *UpdatingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitUpdatingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) UpdatingClause() (localctx IUpdatingClauseContext) {
	localctx = NewUpdatingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CypherParserRULE_updatingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(324)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCREATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(319)
			p.CreateClause()
		}

	case CypherParserMERGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(320)
			p.MergeClause()
		}

	case CypherParserDETACH, CypherParserDELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(321)
			p.DeleteClause()
		}

	case CypherParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(322)
			p.SetClause()
		}

	case CypherParserREMOVE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(323)
			p.RemoveClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadingClauseContext is an interface to support dynamic dispatch.
type IReadingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadingClauseContext differentiates from other interfaces.
	IsReadingClauseContext()
}

type ReadingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadingClauseContext() *ReadingClauseContext {
	var p = new(ReadingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_readingClause
	return p
}

func (*ReadingClauseContext) IsReadingClauseContext() {}

func NewReadingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadingClauseContext {
	var p = new(ReadingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_readingClause

	return p
}

func (s *ReadingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadingClauseContext) MatchClause() IMatchClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatchClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatchClauseContext)
}

func (s *ReadingClauseContext) UnwindClause() IUnwindClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnwindClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnwindClauseContext)
}

func (s *ReadingClauseContext) InQueryCall() IInQueryCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInQueryCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInQueryCallContext)
}

func (s *ReadingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitReadingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReadingClause() (localctx IReadingClauseContext) {
	localctx = NewReadingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CypherParserRULE_readingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(329)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserOPTIONAL, CypherParserMATCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(326)
			p.MatchClause()
		}

	case CypherParserUNWIND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(327)
			p.UnwindClause()
		}

	case CypherParserCALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(328)
			p.InQueryCall()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMatchClauseContext is an interface to support dynamic dispatch.
type IMatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchClauseContext differentiates from other interfaces.
	IsMatchClauseContext()
}

type MatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchClauseContext() *MatchClauseContext {
	var p = new(MatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_matchClause
	return p
}

func (*MatchClauseContext) IsMatchClauseContext() {}

func NewMatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchClauseContext {
	var p = new(MatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_matchClause

	return p
}

func (s *MatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchClauseContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *MatchClauseContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *MatchClauseContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *MatchClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MatchClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MatchClauseContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *MatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMatchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MatchClause() (localctx IMatchClauseContext) {
	localctx = NewMatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CypherParserRULE_matchClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserOPTIONAL {
		{
			p.SetState(331)
			p.Match(CypherParserOPTIONAL)
		}
		{
			p.SetState(332)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(335)
		p.Match(CypherParserMATCH)
	}
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(336)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(339)
		p.Pattern()
	}
	p.SetState(344)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(340)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(343)
			p.WhereClause()
		}

	}

	return localctx
}

// IUnwindClauseContext is an interface to support dynamic dispatch.
type IUnwindClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnwindClauseContext differentiates from other interfaces.
	IsUnwindClauseContext()
}

type UnwindClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnwindClauseContext() *UnwindClauseContext {
	var p = new(UnwindClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_unwindClause
	return p
}

func (*UnwindClauseContext) IsUnwindClauseContext() {}

func NewUnwindClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnwindClauseContext {
	var p = new(UnwindClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unwindClause

	return p
}

func (s *UnwindClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnwindClauseContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *UnwindClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UnwindClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnwindClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnwindClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *UnwindClauseContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *UnwindClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnwindClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnwindClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitUnwindClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) UnwindClause() (localctx IUnwindClauseContext) {
	localctx = NewUnwindClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CypherParserRULE_unwindClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Match(CypherParserUNWIND)
	}
	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(347)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(350)
		p.Expr()
	}
	{
		p.SetState(351)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(352)
		p.Match(CypherParserAS)
	}
	{
		p.SetState(353)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(354)
		p.Variable()
	}

	return localctx
}

// IMergeClauseContext is an interface to support dynamic dispatch.
type IMergeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeClauseContext differentiates from other interfaces.
	IsMergeClauseContext()
}

type MergeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeClauseContext() *MergeClauseContext {
	var p = new(MergeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mergeClause
	return p
}

func (*MergeClauseContext) IsMergeClauseContext() {}

func NewMergeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeClauseContext {
	var p = new(MergeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mergeClause

	return p
}

func (s *MergeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeClauseContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *MergeClauseContext) PatternPart() IPatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternPartContext)
}

func (s *MergeClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MergeClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MergeClauseContext) AllMergeAction() []IMergeActionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeActionContext)(nil)).Elem())
	var tst = make([]IMergeActionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeActionContext)
		}
	}

	return tst
}

func (s *MergeClauseContext) MergeAction(i int) IMergeActionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeActionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeActionContext)
}

func (s *MergeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMergeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MergeClause() (localctx IMergeClauseContext) {
	localctx = NewMergeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CypherParserRULE_mergeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(356)
		p.Match(CypherParserMERGE)
	}
	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(357)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(360)
		p.PatternPart()
	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(361)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(362)
				p.MergeAction()
			}

		}
		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
	}

	return localctx
}

// IMergeActionContext is an interface to support dynamic dispatch.
type IMergeActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeActionContext differentiates from other interfaces.
	IsMergeActionContext()
}

type MergeActionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeActionContext() *MergeActionContext {
	var p = new(MergeActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mergeAction
	return p
}

func (*MergeActionContext) IsMergeActionContext() {}

func NewMergeActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeActionContext {
	var p = new(MergeActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mergeAction

	return p
}

func (s *MergeActionContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeActionContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *MergeActionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MergeActionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MergeActionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *MergeActionContext) SetClause() ISetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetClauseContext)
}

func (s *MergeActionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *MergeActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMergeAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MergeAction() (localctx IMergeActionContext) {
	localctx = NewMergeActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CypherParserRULE_mergeAction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(368)
			p.Match(CypherParserON)
		}
		{
			p.SetState(369)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(370)
			p.Match(CypherParserMATCH)
		}
		{
			p.SetState(371)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(372)
			p.SetClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(373)
			p.Match(CypherParserON)
		}
		{
			p.SetState(374)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(375)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(376)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(377)
			p.SetClause()
		}

	}

	return localctx
}

// ICreateClauseContext is an interface to support dynamic dispatch.
type ICreateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateClauseContext differentiates from other interfaces.
	IsCreateClauseContext()
}

type CreateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateClauseContext() *CreateClauseContext {
	var p = new(CreateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_createClause
	return p
}

func (*CreateClauseContext) IsCreateClauseContext() {}

func NewCreateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateClauseContext {
	var p = new(CreateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_createClause

	return p
}

func (s *CreateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateClauseContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *CreateClauseContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CreateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitCreateClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) CreateClause() (localctx ICreateClauseContext) {
	localctx = NewCreateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CypherParserRULE_createClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(CypherParserCREATE)
	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(381)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(384)
		p.Pattern()
	}

	return localctx
}

// ISetClauseContext is an interface to support dynamic dispatch.
type ISetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetClauseContext differentiates from other interfaces.
	IsSetClauseContext()
}

type SetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetClauseContext() *SetClauseContext {
	var p = new(SetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_setClause
	return p
}

func (*SetClauseContext) IsSetClauseContext() {}

func NewSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetClauseContext {
	var p = new(SetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setClause

	return p
}

func (s *SetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *SetClauseContext) AllSetItem() []ISetItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetItemContext)(nil)).Elem())
	var tst = make([]ISetItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetItemContext)
		}
	}

	return tst
}

func (s *SetClauseContext) SetItem(i int) ISetItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetItemContext)
}

func (s *SetClauseContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *SetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitSetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SetClause() (localctx ISetClauseContext) {
	localctx = NewSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CypherParserRULE_setClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(CypherParserSET)
	}
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(387)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(390)
		p.SetItem()
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__1 {
		{
			p.SetState(391)
			p.Match(CypherParserT__1)
		}
		{
			p.SetState(392)
			p.SetItem()
		}

		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISetItemContext is an interface to support dynamic dispatch.
type ISetItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetItemContext differentiates from other interfaces.
	IsSetItemContext()
}

type SetItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetItemContext() *SetItemContext {
	var p = new(SetItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_setItem
	return p
}

func (*SetItemContext) IsSetItemContext() {}

func NewSetItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetItemContext {
	var p = new(SetItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setItem

	return p
}

func (s *SetItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SetItemContext) PropertyExpr() IPropertyExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyExprContext)
}

func (s *SetItemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SetItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SetItemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SetItemContext) NodeLabels() INodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *SetItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitSetItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SetItem() (localctx ISetItemContext) {
	localctx = NewSetItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CypherParserRULE_setItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(398)
			p.PropertyExpr()
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(399)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(402)
			p.Match(CypherParserT__2)
		}
		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(403)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(406)
			p.Expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(408)
			p.Variable()
		}
		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(409)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(412)
			p.Match(CypherParserT__2)
		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(413)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(416)
			p.Expr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(418)
			p.Variable()
		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(419)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(422)
			p.Match(CypherParserT__3)
		}
		p.SetState(424)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(423)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(426)
			p.Expr()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(428)
			p.Variable()
		}
		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(429)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(432)
			p.NodeLabels()
		}

	}

	return localctx
}

// IDeleteClauseContext is an interface to support dynamic dispatch.
type IDeleteClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteClauseContext differentiates from other interfaces.
	IsDeleteClauseContext()
}

type DeleteClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteClauseContext() *DeleteClauseContext {
	var p = new(DeleteClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_deleteClause
	return p
}

func (*DeleteClauseContext) IsDeleteClauseContext() {}

func NewDeleteClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteClauseContext {
	var p = new(DeleteClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_deleteClause

	return p
}

func (s *DeleteClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteClauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *DeleteClauseContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *DeleteClauseContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DeleteClauseContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *DeleteClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DeleteClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DeleteClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitDeleteClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) DeleteClause() (localctx IDeleteClauseContext) {
	localctx = NewDeleteClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CypherParserRULE_deleteClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDETACH {
		{
			p.SetState(436)
			p.Match(CypherParserDETACH)
		}
		{
			p.SetState(437)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(440)
		p.Match(CypherParserDELETE)
	}
	p.SetState(442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(441)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(444)
		p.Expr()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(446)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(445)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(448)
				p.Match(CypherParserT__1)
			}
			p.SetState(450)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(449)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(452)
				p.Expr()
			}

		}
		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
	}

	return localctx
}

// IRemoveClauseContext is an interface to support dynamic dispatch.
type IRemoveClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemoveClauseContext differentiates from other interfaces.
	IsRemoveClauseContext()
}

type RemoveClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveClauseContext() *RemoveClauseContext {
	var p = new(RemoveClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_removeClause
	return p
}

func (*RemoveClauseContext) IsRemoveClauseContext() {}

func NewRemoveClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveClauseContext {
	var p = new(RemoveClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_removeClause

	return p
}

func (s *RemoveClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveClauseContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *RemoveClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RemoveClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RemoveClauseContext) AllRemoveItem() []IRemoveItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRemoveItemContext)(nil)).Elem())
	var tst = make([]IRemoveItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRemoveItemContext)
		}
	}

	return tst
}

func (s *RemoveClauseContext) RemoveItem(i int) IRemoveItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemoveItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRemoveItemContext)
}

func (s *RemoveClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRemoveClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RemoveClause() (localctx IRemoveClauseContext) {
	localctx = NewRemoveClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CypherParserRULE_removeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(CypherParserREMOVE)
	}
	{
		p.SetState(459)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(460)
		p.RemoveItem()
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(462)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(461)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(464)
				p.Match(CypherParserT__1)
			}
			p.SetState(466)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(465)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(468)
				p.RemoveItem()
			}

		}
		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
	}

	return localctx
}

// IRemoveItemContext is an interface to support dynamic dispatch.
type IRemoveItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemoveItemContext differentiates from other interfaces.
	IsRemoveItemContext()
}

type RemoveItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveItemContext() *RemoveItemContext {
	var p = new(RemoveItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_removeItem
	return p
}

func (*RemoveItemContext) IsRemoveItemContext() {}

func NewRemoveItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveItemContext {
	var p = new(RemoveItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_removeItem

	return p
}

func (s *RemoveItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveItemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *RemoveItemContext) NodeLabels() INodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *RemoveItemContext) PropertyExpr() IPropertyExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyExprContext)
}

func (s *RemoveItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRemoveItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RemoveItem() (localctx IRemoveItemContext) {
	localctx = NewRemoveItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CypherParserRULE_removeItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(474)
			p.Variable()
		}
		{
			p.SetState(475)
			p.NodeLabels()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(477)
			p.PropertyExpr()
		}

	}

	return localctx
}

// IInQueryCallContext is an interface to support dynamic dispatch.
type IInQueryCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInQueryCallContext differentiates from other interfaces.
	IsInQueryCallContext()
}

type InQueryCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInQueryCallContext() *InQueryCallContext {
	var p = new(InQueryCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_inQueryCall
	return p
}

func (*InQueryCallContext) IsInQueryCallContext() {}

func NewInQueryCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InQueryCallContext {
	var p = new(InQueryCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_inQueryCall

	return p
}

func (s *InQueryCallContext) GetParser() antlr.Parser { return s.parser }

func (s *InQueryCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *InQueryCallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *InQueryCallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *InQueryCallContext) ExplicitProcedureInvocation() IExplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitProcedureInvocationContext)
}

func (s *InQueryCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *InQueryCallContext) YieldItems() IYieldItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldItemsContext)
}

func (s *InQueryCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InQueryCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InQueryCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitInQueryCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) InQueryCall() (localctx IInQueryCallContext) {
	localctx = NewInQueryCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CypherParserRULE_inQueryCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(480)
		p.Match(CypherParserCALL)
	}
	{
		p.SetState(481)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(482)
		p.ExplicitProcedureInvocation()
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		p.SetState(484)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(483)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(486)
			p.Match(CypherParserYIELD)
		}
		{
			p.SetState(487)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(488)
			p.YieldItems()
		}

	}

	return localctx
}

// IStandaloneCallContext is an interface to support dynamic dispatch.
type IStandaloneCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandaloneCallContext differentiates from other interfaces.
	IsStandaloneCallContext()
}

type StandaloneCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneCallContext() *StandaloneCallContext {
	var p = new(StandaloneCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_standaloneCall
	return p
}

func (*StandaloneCallContext) IsStandaloneCallContext() {}

func NewStandaloneCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneCallContext {
	var p = new(StandaloneCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_standaloneCall

	return p
}

func (s *StandaloneCallContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *StandaloneCallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StandaloneCallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StandaloneCallContext) ExplicitProcedureInvocation() IExplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitProcedureInvocationContext)
}

func (s *StandaloneCallContext) ImplicitProcedureInvocation() IImplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitProcedureInvocationContext)
}

func (s *StandaloneCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *StandaloneCallContext) YieldItems() IYieldItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldItemsContext)
}

func (s *StandaloneCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitStandaloneCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) StandaloneCall() (localctx IStandaloneCallContext) {
	localctx = NewStandaloneCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CypherParserRULE_standaloneCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(CypherParserCALL)
	}
	{
		p.SetState(492)
		p.Match(CypherParserSP)
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(493)
			p.ExplicitProcedureInvocation()
		}

	case 2:
		{
			p.SetState(494)
			p.ImplicitProcedureInvocation()
		}

	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(497)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(498)
			p.Match(CypherParserYIELD)
		}
		{
			p.SetState(499)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(500)
			p.YieldItems()
		}

	}

	return localctx
}

// IYieldItemsContext is an interface to support dynamic dispatch.
type IYieldItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldItemsContext differentiates from other interfaces.
	IsYieldItemsContext()
}

type YieldItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemsContext() *YieldItemsContext {
	var p = new(YieldItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_yieldItems
	return p
}

func (*YieldItemsContext) IsYieldItemsContext() {}

func NewYieldItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemsContext {
	var p = new(YieldItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_yieldItems

	return p
}

func (s *YieldItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemsContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *YieldItemsContext) AllYieldItem() []IYieldItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IYieldItemContext)(nil)).Elem())
	var tst = make([]IYieldItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IYieldItemContext)
		}
	}

	return tst
}

func (s *YieldItemsContext) YieldItem(i int) IYieldItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IYieldItemContext)
}

func (s *YieldItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *YieldItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *YieldItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitYieldItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) YieldItems() (localctx IYieldItemsContext) {
	localctx = NewYieldItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CypherParserRULE_yieldItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(518)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__4:
		{
			p.SetState(503)
			p.Match(CypherParserT__4)
		}

	case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		{
			p.SetState(504)
			p.YieldItem()
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(506)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(505)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(508)
					p.Match(CypherParserT__1)
				}
				p.SetState(510)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(509)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(512)
					p.YieldItem()
				}

			}
			p.SetState(517)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(520)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(523)
			p.WhereClause()
		}

	}

	return localctx
}

// IYieldItemContext is an interface to support dynamic dispatch.
type IYieldItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldItemContext differentiates from other interfaces.
	IsYieldItemContext()
}

type YieldItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemContext() *YieldItemContext {
	var p = new(YieldItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_yieldItem
	return p
}

func (*YieldItemContext) IsYieldItemContext() {}

func NewYieldItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemContext {
	var p = new(YieldItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_yieldItem

	return p
}

func (s *YieldItemContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *YieldItemContext) ProcedureResultField() IProcedureResultFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureResultFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureResultFieldContext)
}

func (s *YieldItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *YieldItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *YieldItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *YieldItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitYieldItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) YieldItem() (localctx IYieldItemContext) {
	localctx = NewYieldItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CypherParserRULE_yieldItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(531)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(526)
			p.ProcedureResultField()
		}
		{
			p.SetState(527)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(528)
			p.Match(CypherParserAS)
		}
		{
			p.SetState(529)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(533)
		p.Variable()
	}

	return localctx
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_withClause
	return p
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *WithClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *WithClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *WithClauseContext) ReturnBody() IReturnBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnBodyContext)
}

func (s *WithClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *WithClauseContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CypherParserRULE_withClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		p.Match(CypherParserWITH)
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(536)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(539)
			p.Match(CypherParserDISTINCT)
		}

	}
	{
		p.SetState(542)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(543)
		p.ReturnBody()
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(544)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(547)
			p.WhereClause()
		}

	}

	return localctx
}

// IReturnClauseContext is an interface to support dynamic dispatch.
type IReturnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnClauseContext differentiates from other interfaces.
	IsReturnClauseContext()
}

type ReturnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnClauseContext() *ReturnClauseContext {
	var p = new(ReturnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnClause
	return p
}

func (*ReturnClauseContext) IsReturnClauseContext() {}

func NewReturnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnClauseContext {
	var p = new(ReturnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnClause

	return p
}

func (s *ReturnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnClauseContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *ReturnClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnClauseContext) ReturnBody() IReturnBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnBodyContext)
}

func (s *ReturnClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *ReturnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitReturnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReturnClause() (localctx IReturnClauseContext) {
	localctx = NewReturnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CypherParserRULE_returnClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.Match(CypherParserRETURN)
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(551)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(554)
			p.Match(CypherParserDISTINCT)
		}

	}
	{
		p.SetState(557)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(558)
		p.ReturnBody()
	}

	return localctx
}

// IReturnBodyContext is an interface to support dynamic dispatch.
type IReturnBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnBodyContext differentiates from other interfaces.
	IsReturnBodyContext()
}

type ReturnBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnBodyContext() *ReturnBodyContext {
	var p = new(ReturnBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnBody
	return p
}

func (*ReturnBodyContext) IsReturnBodyContext() {}

func NewReturnBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnBodyContext {
	var p = new(ReturnBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnBody

	return p
}

func (s *ReturnBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnBodyContext) ReturnItems() IReturnItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnItemsContext)
}

func (s *ReturnBodyContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnBodyContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnBodyContext) OrderClause() IOrderClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *ReturnBodyContext) SkipClause() ISkipClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISkipClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISkipClauseContext)
}

func (s *ReturnBodyContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ReturnBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitReturnBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReturnBody() (localctx IReturnBodyContext) {
	localctx = NewReturnBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CypherParserRULE_returnBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.ReturnItems()
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(561)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(562)
			p.OrderClause()
		}

	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(565)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(566)
			p.SkipClause()
		}

	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(569)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(570)
			p.LimitClause()
		}

	}

	return localctx
}

// IReturnItemsContext is an interface to support dynamic dispatch.
type IReturnItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnItemsContext differentiates from other interfaces.
	IsReturnItemsContext()
}

type ReturnItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemsContext() *ReturnItemsContext {
	var p = new(ReturnItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnItems
	return p
}

func (*ReturnItemsContext) IsReturnItemsContext() {}

func NewReturnItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemsContext {
	var p = new(ReturnItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnItems

	return p
}

func (s *ReturnItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemsContext) AllReturnItem() []IReturnItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReturnItemContext)(nil)).Elem())
	var tst = make([]IReturnItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReturnItemContext)
		}
	}

	return tst
}

func (s *ReturnItemsContext) ReturnItem(i int) IReturnItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReturnItemContext)
}

func (s *ReturnItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitReturnItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReturnItems() (localctx IReturnItemsContext) {
	localctx = NewReturnItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CypherParserRULE_returnItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(601)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__4:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(573)
			p.Match(CypherParserT__4)
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(575)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(574)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(577)
					p.Match(CypherParserT__1)
				}
				p.SetState(579)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(578)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(581)
					p.ReturnItem()
				}

			}
			p.SetState(586)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
		}

	case CypherParserT__5, CypherParserT__7, CypherParserT__12, CypherParserT__13, CypherParserT__23, CypherParserT__25, CypherParserALL, CypherParserNOT, CypherParserNULL, CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserEXISTS, CypherParserCASE, CypherParserStringLiteral, CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserHexLetter, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(587)
			p.ReturnItem()
		}
		p.SetState(598)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(589)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(588)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(591)
					p.Match(CypherParserT__1)
				}
				p.SetState(593)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(592)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(595)
					p.ReturnItem()
				}

			}
			p.SetState(600)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReturnItemContext is an interface to support dynamic dispatch.
type IReturnItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnItemContext differentiates from other interfaces.
	IsReturnItemContext()
}

type ReturnItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemContext() *ReturnItemContext {
	var p = new(ReturnItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnItem
	return p
}

func (*ReturnItemContext) IsReturnItemContext() {}

func NewReturnItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemContext {
	var p = new(ReturnItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnItem

	return p
}

func (s *ReturnItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ReturnItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *ReturnItemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ReturnItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitReturnItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReturnItem() (localctx IReturnItemContext) {
	localctx = NewReturnItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CypherParserRULE_returnItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(603)
			p.Expr()
		}
		{
			p.SetState(604)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(605)
			p.Match(CypherParserAS)
		}
		{
			p.SetState(606)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(607)
			p.Variable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(609)
			p.Expr()
		}

	}

	return localctx
}

// IOrderClauseContext is an interface to support dynamic dispatch.
type IOrderClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderClauseContext differentiates from other interfaces.
	IsOrderClauseContext()
}

type OrderClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderClauseContext() *OrderClauseContext {
	var p = new(OrderClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_orderClause
	return p
}

func (*OrderClauseContext) IsOrderClauseContext() {}

func NewOrderClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderClauseContext {
	var p = new(OrderClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_orderClause

	return p
}

func (s *OrderClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *OrderClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OrderClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OrderClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *OrderClauseContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *OrderClauseContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OrderClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitOrderClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) OrderClause() (localctx IOrderClauseContext) {
	localctx = NewOrderClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CypherParserRULE_orderClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Match(CypherParserORDER)
	}
	{
		p.SetState(613)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(614)
		p.Match(CypherParserBY)
	}
	{
		p.SetState(615)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(616)
		p.SortItem()
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__1 {
		{
			p.SetState(617)
			p.Match(CypherParserT__1)
		}
		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(618)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(621)
			p.SortItem()
		}

		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISkipClauseContext is an interface to support dynamic dispatch.
type ISkipClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSkipClauseContext differentiates from other interfaces.
	IsSkipClauseContext()
}

type SkipClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkipClauseContext() *SkipClauseContext {
	var p = new(SkipClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_skipClause
	return p
}

func (*SkipClauseContext) IsSkipClauseContext() {}

func NewSkipClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipClauseContext {
	var p = new(SkipClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_skipClause

	return p
}

func (s *SkipClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipClauseContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(CypherParserL_SKIP, 0)
}

func (s *SkipClauseContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *SkipClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SkipClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitSkipClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SkipClause() (localctx ISkipClauseContext) {
	localctx = NewSkipClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CypherParserRULE_skipClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		p.Match(CypherParserL_SKIP)
	}
	{
		p.SetState(628)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(629)
		p.Expr()
	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *LimitClauseContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *LimitClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CypherParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(CypherParserLIMIT)
	}
	{
		p.SetState(632)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(633)
		p.Expr()
	}

	return localctx
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_sortItem
	return p
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SortItemContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *SortItemContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *SortItemContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CypherParserRULE_sortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Expr()
	}
	p.SetState(640)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(636)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(639)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(CypherParserASCENDING-68))|(1<<(CypherParserASC-68))|(1<<(CypherParserDESCENDING-68))|(1<<(CypherParserDESC-68)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_whereClause
	return p
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *WhereClauseContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *WhereClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CypherParserRULE_whereClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.Match(CypherParserWHERE)
	}
	{
		p.SetState(643)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(644)
		p.Expr()
	}

	return localctx
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_pattern
	return p
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) AllPatternPart() []IPatternPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatternPartContext)(nil)).Elem())
	var tst = make([]IPatternPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatternPartContext)
		}
	}

	return tst
}

func (s *PatternContext) PatternPart(i int) IPatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatternPartContext)
}

func (s *PatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CypherParserRULE_pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.PatternPart()
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(648)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(647)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(650)
				p.Match(CypherParserT__1)
			}
			p.SetState(652)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(651)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(654)
				p.PatternPart()
			}

		}
		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}

	return localctx
}

// IPatternPartContext is an interface to support dynamic dispatch.
type IPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternPartContext differentiates from other interfaces.
	IsPatternPartContext()
}

type PatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternPartContext() *PatternPartContext {
	var p = new(PatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternPart
	return p
}

func (*PatternPartContext) IsPatternPartContext() {}

func NewPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternPartContext {
	var p = new(PatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternPart

	return p
}

func (s *PatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternPartContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PatternPartContext) AnonymousPatternPart() IAnonymousPatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymousPatternPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymousPatternPartContext)
}

func (s *PatternPartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternPartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPatternPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternPart() (localctx IPatternPartContext) {
	localctx = NewPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CypherParserRULE_patternPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(671)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(660)
			p.Variable()
		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(661)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(664)
			p.Match(CypherParserT__2)
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(665)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(668)
			p.AnonymousPatternPart()
		}

	case CypherParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(670)
			p.AnonymousPatternPart()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnonymousPatternPartContext is an interface to support dynamic dispatch.
type IAnonymousPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymousPatternPartContext differentiates from other interfaces.
	IsAnonymousPatternPartContext()
}

type AnonymousPatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousPatternPartContext() *AnonymousPatternPartContext {
	var p = new(AnonymousPatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_anonymousPatternPart
	return p
}

func (*AnonymousPatternPartContext) IsAnonymousPatternPartContext() {}

func NewAnonymousPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousPatternPartContext {
	var p = new(AnonymousPatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_anonymousPatternPart

	return p
}

func (s *AnonymousPatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousPatternPartContext) PatternElement() IPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternElementContext)
}

func (s *AnonymousPatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousPatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousPatternPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitAnonymousPatternPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) AnonymousPatternPart() (localctx IAnonymousPatternPartContext) {
	localctx = NewAnonymousPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CypherParserRULE_anonymousPatternPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.PatternElement()
	}

	return localctx
}

// IPatternElementContext is an interface to support dynamic dispatch.
type IPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternElementContext differentiates from other interfaces.
	IsPatternElementContext()
}

type PatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternElementContext() *PatternElementContext {
	var p = new(PatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternElement
	return p
}

func (*PatternElementContext) IsPatternElementContext() {}

func NewPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternElementContext {
	var p = new(PatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternElement

	return p
}

func (s *PatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternElementContext) NodePattern() INodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *PatternElementContext) AllPatternElementChain() []IPatternElementChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatternElementChainContext)(nil)).Elem())
	var tst = make([]IPatternElementChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatternElementChainContext)
		}
	}

	return tst
}

func (s *PatternElementContext) PatternElementChain(i int) IPatternElementChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternElementChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatternElementChainContext)
}

func (s *PatternElementContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternElementContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternElementContext) PatternElement() IPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternElementContext)
}

func (s *PatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPatternElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternElement() (localctx IPatternElementContext) {
	localctx = NewPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CypherParserRULE_patternElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(675)
			p.NodePattern()
		}
		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(677)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(676)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(679)
					p.PatternElementChain()
				}

			}
			p.SetState(684)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(685)
			p.Match(CypherParserT__5)
		}
		{
			p.SetState(686)
			p.PatternElement()
		}
		{
			p.SetState(687)
			p.Match(CypherParserT__6)
		}

	}

	return localctx
}

// INodePatternContext is an interface to support dynamic dispatch.
type INodePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodePatternContext differentiates from other interfaces.
	IsNodePatternContext()
}

type NodePatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodePatternContext() *NodePatternContext {
	var p = new(NodePatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodePattern
	return p
}

func (*NodePatternContext) IsNodePatternContext() {}

func NewNodePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodePatternContext {
	var p = new(NodePatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodePattern

	return p
}

func (s *NodePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *NodePatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NodePatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NodePatternContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *NodePatternContext) NodeLabels() INodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *NodePatternContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *NodePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodePatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitNodePattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NodePattern() (localctx INodePatternContext) {
	localctx = NewNodePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CypherParserRULE_nodePattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(691)
		p.Match(CypherParserT__5)
	}
	p.SetState(693)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(692)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserCOUNT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserHexLetter-83)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0) {
		{
			p.SetState(695)
			p.Variable()
		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(696)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__9 {
		{
			p.SetState(701)
			p.NodeLabels()
		}
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(702)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__23 || _la == CypherParserT__25 {
		{
			p.SetState(707)
			p.Properties()
		}
		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(708)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(713)
		p.Match(CypherParserT__6)
	}

	return localctx
}

// IPatternElementChainContext is an interface to support dynamic dispatch.
type IPatternElementChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternElementChainContext differentiates from other interfaces.
	IsPatternElementChainContext()
}

type PatternElementChainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternElementChainContext() *PatternElementChainContext {
	var p = new(PatternElementChainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternElementChain
	return p
}

func (*PatternElementChainContext) IsPatternElementChainContext() {}

func NewPatternElementChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternElementChainContext {
	var p = new(PatternElementChainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternElementChain

	return p
}

func (s *PatternElementChainContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternElementChainContext) RelationshipPattern() IRelationshipPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipPatternContext)
}

func (s *PatternElementChainContext) NodePattern() INodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *PatternElementChainContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PatternElementChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternElementChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternElementChainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPatternElementChain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternElementChain() (localctx IPatternElementChainContext) {
	localctx = NewPatternElementChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CypherParserRULE_patternElementChain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.RelationshipPattern()
	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(716)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(719)
		p.NodePattern()
	}

	return localctx
}

// IRelationshipPatternContext is an interface to support dynamic dispatch.
type IRelationshipPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipPatternContext differentiates from other interfaces.
	IsRelationshipPatternContext()
}

type RelationshipPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipPatternContext() *RelationshipPatternContext {
	var p = new(RelationshipPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPattern
	return p
}

func (*RelationshipPatternContext) IsRelationshipPatternContext() {}

func NewRelationshipPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipPatternContext {
	var p = new(RelationshipPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipPattern

	return p
}

func (s *RelationshipPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipPatternContext) LeftArrowHead() ILeftArrowHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeftArrowHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeftArrowHeadContext)
}

func (s *RelationshipPatternContext) AllDash() []IDashContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDashContext)(nil)).Elem())
	var tst = make([]IDashContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDashContext)
		}
	}

	return tst
}

func (s *RelationshipPatternContext) Dash(i int) IDashContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDashContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDashContext)
}

func (s *RelationshipPatternContext) RightArrowHead() IRightArrowHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRightArrowHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRightArrowHeadContext)
}

func (s *RelationshipPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipPatternContext) RelationshipDetail() IRelationshipDetailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipDetailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipDetailContext)
}

func (s *RelationshipPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRelationshipPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelationshipPattern() (localctx IRelationshipPatternContext) {
	localctx = NewRelationshipPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CypherParserRULE_relationshipPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(721)
			p.LeftArrowHead()
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(722)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(725)
			p.Dash()
		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(726)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__7 {
			{
				p.SetState(729)
				p.RelationshipDetail()
			}

		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(732)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(735)
			p.Dash()
		}
		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(736)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(739)
			p.RightArrowHead()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(741)
			p.LeftArrowHead()
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(742)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(745)
			p.Dash()
		}
		p.SetState(747)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(746)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__7 {
			{
				p.SetState(749)
				p.RelationshipDetail()
			}

		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(752)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(755)
			p.Dash()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(757)
			p.Dash()
		}
		p.SetState(759)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(758)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__7 {
			{
				p.SetState(761)
				p.RelationshipDetail()
			}

		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(764)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(767)
			p.Dash()
		}
		p.SetState(769)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(768)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(771)
			p.RightArrowHead()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(773)
			p.Dash()
		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(774)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__7 {
			{
				p.SetState(777)
				p.RelationshipDetail()
			}

		}
		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(780)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(783)
			p.Dash()
		}

	}

	return localctx
}

// IRelationshipDetailContext is an interface to support dynamic dispatch.
type IRelationshipDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipDetailContext differentiates from other interfaces.
	IsRelationshipDetailContext()
}

type RelationshipDetailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipDetailContext() *RelationshipDetailContext {
	var p = new(RelationshipDetailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipDetail
	return p
}

func (*RelationshipDetailContext) IsRelationshipDetailContext() {}

func NewRelationshipDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipDetailContext {
	var p = new(RelationshipDetailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipDetail

	return p
}

func (s *RelationshipDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipDetailContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipDetailContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipDetailContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *RelationshipDetailContext) RelationshipTypes() IRelationshipTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipTypesContext)
}

func (s *RelationshipDetailContext) RangeLiteral() IRangeLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRangeLiteralContext)
}

func (s *RelationshipDetailContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *RelationshipDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipDetailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRelationshipDetail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelationshipDetail() (localctx IRelationshipDetailContext) {
	localctx = NewRelationshipDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CypherParserRULE_relationshipDetail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Match(CypherParserT__7)
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(788)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserCOUNT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserHexLetter-83)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0) {
		{
			p.SetState(791)
			p.Variable()
		}
		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(792)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__9 {
		{
			p.SetState(797)
			p.RelationshipTypes()
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(798)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(804)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__4 {
		{
			p.SetState(803)
			p.RangeLiteral()
		}

	}
	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__23 || _la == CypherParserT__25 {
		{
			p.SetState(806)
			p.Properties()
		}
		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(807)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(812)
		p.Match(CypherParserT__8)
	}

	return localctx
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_properties
	return p
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) MapLiteral() IMapLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *PropertiesContext) Parameter() IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CypherParserRULE_properties)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(816)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__23:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(814)
			p.MapLiteral()
		}

	case CypherParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(815)
			p.Parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRelationshipTypesContext is an interface to support dynamic dispatch.
type IRelationshipTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipTypesContext differentiates from other interfaces.
	IsRelationshipTypesContext()
}

type RelationshipTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipTypesContext() *RelationshipTypesContext {
	var p = new(RelationshipTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipTypes
	return p
}

func (*RelationshipTypesContext) IsRelationshipTypesContext() {}

func NewRelationshipTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipTypesContext {
	var p = new(RelationshipTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipTypes

	return p
}

func (s *RelationshipTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipTypesContext) AllRelTypeName() []IRelTypeNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelTypeNameContext)(nil)).Elem())
	var tst = make([]IRelTypeNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelTypeNameContext)
		}
	}

	return tst
}

func (s *RelationshipTypesContext) RelTypeName(i int) IRelTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelTypeNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelTypeNameContext)
}

func (s *RelationshipTypesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipTypesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipTypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRelationshipTypes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelationshipTypes() (localctx IRelationshipTypesContext) {
	localctx = NewRelationshipTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CypherParserRULE_relationshipTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.Match(CypherParserT__9)
	}
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(819)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(822)
		p.RelTypeName()
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(824)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(823)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(826)
				p.Match(CypherParserT__10)
			}
			p.SetState(828)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserT__9 {
				{
					p.SetState(827)
					p.Match(CypherParserT__9)
				}

			}
			p.SetState(831)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(830)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(833)
				p.RelTypeName()
			}

		}
		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}

	return localctx
}

// INodeLabelsContext is an interface to support dynamic dispatch.
type INodeLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodeLabelsContext differentiates from other interfaces.
	IsNodeLabelsContext()
}

type NodeLabelsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeLabelsContext() *NodeLabelsContext {
	var p = new(NodeLabelsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLabels
	return p
}

func (*NodeLabelsContext) IsNodeLabelsContext() {}

func NewNodeLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeLabelsContext {
	var p = new(NodeLabelsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeLabels

	return p
}

func (s *NodeLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeLabelsContext) AllNodeLabel() []INodeLabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INodeLabelContext)(nil)).Elem())
	var tst = make([]INodeLabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INodeLabelContext)
		}
	}

	return tst
}

func (s *NodeLabelsContext) NodeLabel(i int) INodeLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INodeLabelContext)
}

func (s *NodeLabelsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NodeLabelsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NodeLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeLabelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitNodeLabels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NodeLabels() (localctx INodeLabelsContext) {
	localctx = NewNodeLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CypherParserRULE_nodeLabels)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.NodeLabel()
	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(841)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(840)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(843)
				p.NodeLabel()
			}

		}
		p.SetState(848)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// INodeLabelContext is an interface to support dynamic dispatch.
type INodeLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodeLabelContext differentiates from other interfaces.
	IsNodeLabelContext()
}

type NodeLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeLabelContext() *NodeLabelContext {
	var p = new(NodeLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLabel
	return p
}

func (*NodeLabelContext) IsNodeLabelContext() {}

func NewNodeLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeLabelContext {
	var p = new(NodeLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeLabel

	return p
}

func (s *NodeLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeLabelContext) LabelName() ILabelNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *NodeLabelContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *NodeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitNodeLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NodeLabel() (localctx INodeLabelContext) {
	localctx = NewNodeLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CypherParserRULE_nodeLabel)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)
		p.Match(CypherParserT__9)
	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(850)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(853)
		p.LabelName()
	}

	return localctx
}

// IRangeLiteralContext is an interface to support dynamic dispatch.
type IRangeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeLiteralContext differentiates from other interfaces.
	IsRangeLiteralContext()
}

type RangeLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeLiteralContext() *RangeLiteralContext {
	var p = new(RangeLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_rangeLiteral
	return p
}

func (*RangeLiteralContext) IsRangeLiteralContext() {}

func NewRangeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeLiteralContext {
	var p = new(RangeLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_rangeLiteral

	return p
}

func (s *RangeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RangeLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RangeLiteralContext) MinHops() IMinHopsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMinHopsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMinHopsContext)
}

func (s *RangeLiteralContext) MaxHops() IMaxHopsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMaxHopsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMaxHopsContext)
}

func (s *RangeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRangeLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RangeLiteral() (localctx IRangeLiteralContext) {
	localctx = NewRangeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CypherParserRULE_rangeLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(855)
		p.Match(CypherParserT__4)
	}
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(856)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(CypherParserHexInteger-97))|(1<<(CypherParserDecimalInteger-97))|(1<<(CypherParserOctalInteger-97)))) != 0 {
		{
			p.SetState(859)
			p.MinHops()
		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(860)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__11 {
		{
			p.SetState(865)
			p.Match(CypherParserT__11)
		}
		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(866)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(CypherParserHexInteger-97))|(1<<(CypherParserDecimalInteger-97))|(1<<(CypherParserOctalInteger-97)))) != 0 {
			{
				p.SetState(869)
				p.MaxHops()
			}
			p.SetState(871)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(870)
					p.Match(CypherParserSP)
				}

			}

		}

	}

	return localctx
}

// IMinHopsContext is an interface to support dynamic dispatch.
type IMinHopsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMinHopsContext differentiates from other interfaces.
	IsMinHopsContext()
}

type MinHopsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinHopsContext() *MinHopsContext {
	var p = new(MinHopsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_minHops
	return p
}

func (*MinHopsContext) IsMinHopsContext() {}

func NewMinHopsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinHopsContext {
	var p = new(MinHopsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_minHops

	return p
}

func (s *MinHopsContext) GetParser() antlr.Parser { return s.parser }

func (s *MinHopsContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MinHopsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinHopsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinHopsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMinHops(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MinHops() (localctx IMinHopsContext) {
	localctx = NewMinHopsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CypherParserRULE_minHops)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.IntegerLiteral()
	}

	return localctx
}

// IMaxHopsContext is an interface to support dynamic dispatch.
type IMaxHopsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMaxHopsContext differentiates from other interfaces.
	IsMaxHopsContext()
}

type MaxHopsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaxHopsContext() *MaxHopsContext {
	var p = new(MaxHopsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_maxHops
	return p
}

func (*MaxHopsContext) IsMaxHopsContext() {}

func NewMaxHopsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaxHopsContext {
	var p = new(MaxHopsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_maxHops

	return p
}

func (s *MaxHopsContext) GetParser() antlr.Parser { return s.parser }

func (s *MaxHopsContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MaxHopsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaxHopsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaxHopsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMaxHops(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MaxHops() (localctx IMaxHopsContext) {
	localctx = NewMaxHopsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CypherParserRULE_maxHops)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.IntegerLiteral()
	}

	return localctx
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_labelName
	return p
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitLabelName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) LabelName() (localctx ILabelNameContext) {
	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CypherParserRULE_labelName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.SchemaName()
	}

	return localctx
}

// IRelTypeNameContext is an interface to support dynamic dispatch.
type IRelTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelTypeNameContext differentiates from other interfaces.
	IsRelTypeNameContext()
}

type RelTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelTypeNameContext() *RelTypeNameContext {
	var p = new(RelTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relTypeName
	return p
}

func (*RelTypeNameContext) IsRelTypeNameContext() {}

func NewRelTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelTypeNameContext {
	var p = new(RelTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relTypeName

	return p
}

func (s *RelTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RelTypeNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *RelTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelTypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRelTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelTypeName() (localctx IRelTypeNameContext) {
	localctx = NewRelTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CypherParserRULE_relTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.SchemaName()
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) OrExpr() IOrExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrExprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CypherParserRULE_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.OrExpr()
	}

	return localctx
}

// IOrExprContext is an interface to support dynamic dispatch.
type IOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrExprContext differentiates from other interfaces.
	IsOrExprContext()
}

type OrExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExprContext() *OrExprContext {
	var p = new(OrExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_orExpr
	return p
}

func (*OrExprContext) IsOrExprContext() {}

func NewOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExprContext {
	var p = new(OrExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_orExpr

	return p
}

func (s *OrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExprContext) AllXorExpr() []IXorExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXorExprContext)(nil)).Elem())
	var tst = make([]IXorExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXorExprContext)
		}
	}

	return tst
}

func (s *OrExprContext) XorExpr(i int) IXorExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXorExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXorExprContext)
}

func (s *OrExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OrExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OrExprContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserOR)
}

func (s *OrExprContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserOR, i)
}

func (s *OrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) OrExpr() (localctx IOrExprContext) {
	localctx = NewOrExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CypherParserRULE_orExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(887)
		p.XorExpr()
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(888)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(889)
				p.Match(CypherParserOR)
			}
			{
				p.SetState(890)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(891)
				p.XorExpr()
			}

		}
		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())
	}

	return localctx
}

// IXorExprContext is an interface to support dynamic dispatch.
type IXorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXorExprContext differentiates from other interfaces.
	IsXorExprContext()
}

type XorExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXorExprContext() *XorExprContext {
	var p = new(XorExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_xorExpr
	return p
}

func (*XorExprContext) IsXorExprContext() {}

func NewXorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XorExprContext {
	var p = new(XorExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_xorExpr

	return p
}

func (s *XorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *XorExprContext) AllAndExpr() []IAndExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAndExprContext)(nil)).Elem())
	var tst = make([]IAndExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAndExprContext)
		}
	}

	return tst
}

func (s *XorExprContext) AndExpr(i int) IAndExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAndExprContext)
}

func (s *XorExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *XorExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *XorExprContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserXOR)
}

func (s *XorExprContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, i)
}

func (s *XorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitXorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) XorExpr() (localctx IXorExprContext) {
	localctx = NewXorExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CypherParserRULE_xorExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.AndExpr()
	}
	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(898)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(899)
				p.Match(CypherParserXOR)
			}
			{
				p.SetState(900)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(901)
				p.AndExpr()
			}

		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext())
	}

	return localctx
}

// IAndExprContext is an interface to support dynamic dispatch.
type IAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndExprContext differentiates from other interfaces.
	IsAndExprContext()
}

type AndExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExprContext() *AndExprContext {
	var p = new(AndExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_andExpr
	return p
}

func (*AndExprContext) IsAndExprContext() {}

func NewAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExprContext {
	var p = new(AndExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_andExpr

	return p
}

func (s *AndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExprContext) AllNotExpr() []INotExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INotExprContext)(nil)).Elem())
	var tst = make([]INotExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INotExprContext)
		}
	}

	return tst
}

func (s *AndExprContext) NotExpr(i int) INotExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INotExprContext)
}

func (s *AndExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AndExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AndExprContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(CypherParserAND)
}

func (s *AndExprContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserAND, i)
}

func (s *AndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) AndExpr() (localctx IAndExprContext) {
	localctx = NewAndExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CypherParserRULE_andExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.NotExpr()
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(908)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(909)
				p.Match(CypherParserAND)
			}
			{
				p.SetState(910)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(911)
				p.NotExpr()
			}

		}
		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())
	}

	return localctx
}

// INotExprContext is an interface to support dynamic dispatch.
type INotExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotExprContext differentiates from other interfaces.
	IsNotExprContext()
}

type NotExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotExprContext() *NotExprContext {
	var p = new(NotExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_notExpr
	return p
}

func (*NotExprContext) IsNotExprContext() {}

func NewNotExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotExprContext {
	var p = new(NotExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_notExpr

	return p
}

func (s *NotExprContext) GetParser() antlr.Parser { return s.parser }

func (s *NotExprContext) ComparisonExpr() IComparisonExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *NotExprContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserNOT)
}

func (s *NotExprContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, i)
}

func (s *NotExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NotExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NotExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitNotExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NotExpr() (localctx INotExprContext) {
	localctx = NewNotExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CypherParserRULE_notExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserNOT {
		{
			p.SetState(917)
			p.Match(CypherParserNOT)
		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(918)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(926)
		p.ComparisonExpr()
	}

	return localctx
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_comparisonExpr
	return p
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) AddOrSubtractExpr() IAddOrSubtractExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOrSubtractExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddOrSubtractExprContext)
}

func (s *ComparisonExprContext) AllPartialComparisonExpr() []IPartialComparisonExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPartialComparisonExprContext)(nil)).Elem())
	var tst = make([]IPartialComparisonExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPartialComparisonExprContext)
		}
	}

	return tst
}

func (s *ComparisonExprContext) PartialComparisonExpr(i int) IPartialComparisonExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialComparisonExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPartialComparisonExprContext)
}

func (s *ComparisonExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ComparisonExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ComparisonExpr() (localctx IComparisonExprContext) {
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CypherParserRULE_comparisonExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.AddOrSubtractExpr()
	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(930)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(929)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(932)
				p.PartialComparisonExpr()
			}

		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}

	return localctx
}

// IAddOrSubtractExprContext is an interface to support dynamic dispatch.
type IAddOrSubtractExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddOrSubtractExprContext differentiates from other interfaces.
	IsAddOrSubtractExprContext()
}

type AddOrSubtractExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddOrSubtractExprContext() *AddOrSubtractExprContext {
	var p = new(AddOrSubtractExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_addOrSubtractExpr
	return p
}

func (*AddOrSubtractExprContext) IsAddOrSubtractExprContext() {}

func NewAddOrSubtractExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddOrSubtractExprContext {
	var p = new(AddOrSubtractExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_addOrSubtractExpr

	return p
}

func (s *AddOrSubtractExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AddOrSubtractExprContext) AllMultiplyDivideModuloExpr() []IMultiplyDivideModuloExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplyDivideModuloExprContext)(nil)).Elem())
	var tst = make([]IMultiplyDivideModuloExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplyDivideModuloExprContext)
		}
	}

	return tst
}

func (s *AddOrSubtractExprContext) MultiplyDivideModuloExpr(i int) IMultiplyDivideModuloExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyDivideModuloExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplyDivideModuloExprContext)
}

func (s *AddOrSubtractExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AddOrSubtractExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AddOrSubtractExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddOrSubtractExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddOrSubtractExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitAddOrSubtractExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) AddOrSubtractExpr() (localctx IAddOrSubtractExprContext) {
	localctx = NewAddOrSubtractExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CypherParserRULE_addOrSubtractExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(938)
		p.MultiplyDivideModuloExpr()
	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(955)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
			case 1:
				p.SetState(940)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(939)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(942)
					p.Match(CypherParserT__12)
				}
				p.SetState(944)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(943)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(946)
					p.MultiplyDivideModuloExpr()
				}

			case 2:
				p.SetState(948)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(947)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(950)
					p.Match(CypherParserT__13)
				}
				p.SetState(952)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(951)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(954)
					p.MultiplyDivideModuloExpr()
				}

			}

		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiplyDivideModuloExprContext is an interface to support dynamic dispatch.
type IMultiplyDivideModuloExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyDivideModuloExprContext differentiates from other interfaces.
	IsMultiplyDivideModuloExprContext()
}

type MultiplyDivideModuloExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyDivideModuloExprContext() *MultiplyDivideModuloExprContext {
	var p = new(MultiplyDivideModuloExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_multiplyDivideModuloExpr
	return p
}

func (*MultiplyDivideModuloExprContext) IsMultiplyDivideModuloExprContext() {}

func NewMultiplyDivideModuloExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyDivideModuloExprContext {
	var p = new(MultiplyDivideModuloExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multiplyDivideModuloExpr

	return p
}

func (s *MultiplyDivideModuloExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyDivideModuloExprContext) AllPowerOfExpr() []IPowerOfExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPowerOfExprContext)(nil)).Elem())
	var tst = make([]IPowerOfExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPowerOfExprContext)
		}
	}

	return tst
}

func (s *MultiplyDivideModuloExprContext) PowerOfExpr(i int) IPowerOfExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerOfExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPowerOfExprContext)
}

func (s *MultiplyDivideModuloExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MultiplyDivideModuloExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MultiplyDivideModuloExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyDivideModuloExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyDivideModuloExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMultiplyDivideModuloExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MultiplyDivideModuloExpr() (localctx IMultiplyDivideModuloExprContext) {
	localctx = NewMultiplyDivideModuloExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CypherParserRULE_multiplyDivideModuloExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(960)
		p.PowerOfExpr()
	}
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(985)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) {
			case 1:
				p.SetState(962)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(961)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(964)
					p.Match(CypherParserT__4)
				}
				p.SetState(966)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(965)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(968)
					p.PowerOfExpr()
				}

			case 2:
				p.SetState(970)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(969)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(972)
					p.Match(CypherParserT__14)
				}
				p.SetState(974)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(973)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(976)
					p.PowerOfExpr()
				}

			case 3:
				p.SetState(978)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(977)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(980)
					p.Match(CypherParserT__15)
				}
				p.SetState(982)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(981)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(984)
					p.PowerOfExpr()
				}

			}

		}
		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())
	}

	return localctx
}

// IPowerOfExprContext is an interface to support dynamic dispatch.
type IPowerOfExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerOfExprContext differentiates from other interfaces.
	IsPowerOfExprContext()
}

type PowerOfExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerOfExprContext() *PowerOfExprContext {
	var p = new(PowerOfExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_powerOfExpr
	return p
}

func (*PowerOfExprContext) IsPowerOfExprContext() {}

func NewPowerOfExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerOfExprContext {
	var p = new(PowerOfExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_powerOfExpr

	return p
}

func (s *PowerOfExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerOfExprContext) AllUnaryAddOrSubtractExpr() []IUnaryAddOrSubtractExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnaryAddOrSubtractExprContext)(nil)).Elem())
	var tst = make([]IUnaryAddOrSubtractExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnaryAddOrSubtractExprContext)
		}
	}

	return tst
}

func (s *PowerOfExprContext) UnaryAddOrSubtractExpr(i int) IUnaryAddOrSubtractExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryAddOrSubtractExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnaryAddOrSubtractExprContext)
}

func (s *PowerOfExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PowerOfExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PowerOfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerOfExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerOfExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPowerOfExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PowerOfExpr() (localctx IPowerOfExprContext) {
	localctx = NewPowerOfExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CypherParserRULE_powerOfExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		p.UnaryAddOrSubtractExpr()
	}
	p.SetState(1001)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(992)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(991)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(994)
				p.Match(CypherParserT__16)
			}
			p.SetState(996)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(995)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(998)
				p.UnaryAddOrSubtractExpr()
			}

		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())
	}

	return localctx
}

// IUnaryAddOrSubtractExprContext is an interface to support dynamic dispatch.
type IUnaryAddOrSubtractExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryAddOrSubtractExprContext differentiates from other interfaces.
	IsUnaryAddOrSubtractExprContext()
}

type UnaryAddOrSubtractExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryAddOrSubtractExprContext() *UnaryAddOrSubtractExprContext {
	var p = new(UnaryAddOrSubtractExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_unaryAddOrSubtractExpr
	return p
}

func (*UnaryAddOrSubtractExprContext) IsUnaryAddOrSubtractExprContext() {}

func NewUnaryAddOrSubtractExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryAddOrSubtractExprContext {
	var p = new(UnaryAddOrSubtractExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unaryAddOrSubtractExpr

	return p
}

func (s *UnaryAddOrSubtractExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryAddOrSubtractExprContext) StringListNullOperatorExpr() IStringListNullOperatorExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringListNullOperatorExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringListNullOperatorExprContext)
}

func (s *UnaryAddOrSubtractExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnaryAddOrSubtractExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnaryAddOrSubtractExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddOrSubtractExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryAddOrSubtractExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitUnaryAddOrSubtractExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) UnaryAddOrSubtractExpr() (localctx IUnaryAddOrSubtractExprContext) {
	localctx = NewUnaryAddOrSubtractExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CypherParserRULE_unaryAddOrSubtractExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__12 || _la == CypherParserT__13 {
		p.SetState(1004)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserT__12 || _la == CypherParserT__13) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1005)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1013)
		p.StringListNullOperatorExpr()
	}

	return localctx
}

// IStringListNullOperatorExprContext is an interface to support dynamic dispatch.
type IStringListNullOperatorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringListNullOperatorExprContext differentiates from other interfaces.
	IsStringListNullOperatorExprContext()
}

type StringListNullOperatorExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListNullOperatorExprContext() *StringListNullOperatorExprContext {
	var p = new(StringListNullOperatorExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_stringListNullOperatorExpr
	return p
}

func (*StringListNullOperatorExprContext) IsStringListNullOperatorExprContext() {}

func NewStringListNullOperatorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListNullOperatorExprContext {
	var p = new(StringListNullOperatorExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stringListNullOperatorExpr

	return p
}

func (s *StringListNullOperatorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListNullOperatorExprContext) PropertyOrLabelsExpr() IPropertyOrLabelsExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyOrLabelsExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyOrLabelsExprContext)
}

func (s *StringListNullOperatorExprContext) AllStringOperatorExpr() []IStringOperatorExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringOperatorExprContext)(nil)).Elem())
	var tst = make([]IStringOperatorExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringOperatorExprContext)
		}
	}

	return tst
}

func (s *StringListNullOperatorExprContext) StringOperatorExpr(i int) IStringOperatorExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringOperatorExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringOperatorExprContext)
}

func (s *StringListNullOperatorExprContext) AllListOperatorExpr() []IListOperatorExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IListOperatorExprContext)(nil)).Elem())
	var tst = make([]IListOperatorExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IListOperatorExprContext)
		}
	}

	return tst
}

func (s *StringListNullOperatorExprContext) ListOperatorExpr(i int) IListOperatorExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListOperatorExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IListOperatorExprContext)
}

func (s *StringListNullOperatorExprContext) AllNullOperatorExpr() []INullOperatorExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INullOperatorExprContext)(nil)).Elem())
	var tst = make([]INullOperatorExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INullOperatorExprContext)
		}
	}

	return tst
}

func (s *StringListNullOperatorExprContext) NullOperatorExpr(i int) INullOperatorExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullOperatorExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INullOperatorExprContext)
}

func (s *StringListNullOperatorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListNullOperatorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListNullOperatorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitStringListNullOperatorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) StringListNullOperatorExpr() (localctx IStringListNullOperatorExprContext) {
	localctx = NewStringListNullOperatorExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CypherParserRULE_stringListNullOperatorExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.PropertyOrLabelsExpr()
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1019)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1016)
					p.StringOperatorExpr()
				}

			case 2:
				{
					p.SetState(1017)
					p.ListOperatorExpr()
				}

			case 3:
				{
					p.SetState(1018)
					p.NullOperatorExpr()
				}

			}

		}
		p.SetState(1023)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())
	}

	return localctx
}

// IListOperatorExprContext is an interface to support dynamic dispatch.
type IListOperatorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListOperatorExprContext differentiates from other interfaces.
	IsListOperatorExprContext()
}

type ListOperatorExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListOperatorExprContext() *ListOperatorExprContext {
	var p = new(ListOperatorExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_listOperatorExpr
	return p
}

func (*ListOperatorExprContext) IsListOperatorExprContext() {}

func NewListOperatorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListOperatorExprContext {
	var p = new(ListOperatorExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listOperatorExpr

	return p
}

func (s *ListOperatorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ListOperatorExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ListOperatorExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ListOperatorExprContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *ListOperatorExprContext) PropertyOrLabelsExpr() IPropertyOrLabelsExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyOrLabelsExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyOrLabelsExprContext)
}

func (s *ListOperatorExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ListOperatorExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ListOperatorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListOperatorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListOperatorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitListOperatorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ListOperatorExpr() (localctx IListOperatorExprContext) {
	localctx = NewListOperatorExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CypherParserRULE_listOperatorExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1024)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1025)
			p.Match(CypherParserIN)
		}
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1026)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1029)
			p.PropertyOrLabelsExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1031)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1030)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1033)
			p.Match(CypherParserT__7)
		}
		{
			p.SetState(1034)
			p.Expr()
		}
		{
			p.SetState(1035)
			p.Match(CypherParserT__8)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1037)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1040)
			p.Match(CypherParserT__7)
		}
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__5)|(1<<CypherParserT__7)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__23)|(1<<CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-82)&-(0x1f+1)) == 0 && ((1<<uint((_la-82)))&((1<<(CypherParserNULL-82))|(1<<(CypherParserCOUNT-82))|(1<<(CypherParserANY-82))|(1<<(CypherParserNONE-82))|(1<<(CypherParserSINGLE-82))|(1<<(CypherParserTRUE-82))|(1<<(CypherParserFALSE-82))|(1<<(CypherParserEXISTS-82))|(1<<(CypherParserCASE-82))|(1<<(CypherParserStringLiteral-82))|(1<<(CypherParserHexInteger-82))|(1<<(CypherParserDecimalInteger-82))|(1<<(CypherParserOctalInteger-82))|(1<<(CypherParserHexLetter-82))|(1<<(CypherParserExponentDecimalReal-82))|(1<<(CypherParserRegularDecimalReal-82)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0) {
			{
				p.SetState(1041)
				p.Expr()
			}

		}
		{
			p.SetState(1044)
			p.Match(CypherParserT__11)
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__5)|(1<<CypherParserT__7)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__23)|(1<<CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-82)&-(0x1f+1)) == 0 && ((1<<uint((_la-82)))&((1<<(CypherParserNULL-82))|(1<<(CypherParserCOUNT-82))|(1<<(CypherParserANY-82))|(1<<(CypherParserNONE-82))|(1<<(CypherParserSINGLE-82))|(1<<(CypherParserTRUE-82))|(1<<(CypherParserFALSE-82))|(1<<(CypherParserEXISTS-82))|(1<<(CypherParserCASE-82))|(1<<(CypherParserStringLiteral-82))|(1<<(CypherParserHexInteger-82))|(1<<(CypherParserDecimalInteger-82))|(1<<(CypherParserOctalInteger-82))|(1<<(CypherParserHexLetter-82))|(1<<(CypherParserExponentDecimalReal-82))|(1<<(CypherParserRegularDecimalReal-82)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0) {
			{
				p.SetState(1045)
				p.Expr()
			}

		}
		{
			p.SetState(1048)
			p.Match(CypherParserT__8)
		}

	}

	return localctx
}

// IStringOperatorExprContext is an interface to support dynamic dispatch.
type IStringOperatorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringOperatorExprContext differentiates from other interfaces.
	IsStringOperatorExprContext()
}

type StringOperatorExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringOperatorExprContext() *StringOperatorExprContext {
	var p = new(StringOperatorExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_stringOperatorExpr
	return p
}

func (*StringOperatorExprContext) IsStringOperatorExprContext() {}

func NewStringOperatorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringOperatorExprContext {
	var p = new(StringOperatorExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stringOperatorExpr

	return p
}

func (s *StringOperatorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StringOperatorExprContext) PropertyOrLabelsExpr() IPropertyOrLabelsExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyOrLabelsExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyOrLabelsExprContext)
}

func (s *StringOperatorExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StringOperatorExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StringOperatorExprContext) STARTS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, 0)
}

func (s *StringOperatorExprContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *StringOperatorExprContext) ENDS() antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, 0)
}

func (s *StringOperatorExprContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, 0)
}

func (s *StringOperatorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringOperatorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringOperatorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitStringOperatorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) StringOperatorExpr() (localctx IStringOperatorExprContext) {
	localctx = NewStringOperatorExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CypherParserRULE_stringOperatorExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1051)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1052)
			p.Match(CypherParserSTARTS)
		}
		{
			p.SetState(1053)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1054)
			p.Match(CypherParserWITH)
		}

	case 2:
		{
			p.SetState(1055)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1056)
			p.Match(CypherParserENDS)
		}
		{
			p.SetState(1057)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1058)
			p.Match(CypherParserWITH)
		}

	case 3:
		{
			p.SetState(1059)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1060)
			p.Match(CypherParserCONTAINS)
		}

	}
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1063)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1066)
		p.PropertyOrLabelsExpr()
	}

	return localctx
}

// INullOperatorExprContext is an interface to support dynamic dispatch.
type INullOperatorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullOperatorExprContext differentiates from other interfaces.
	IsNullOperatorExprContext()
}

type NullOperatorExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullOperatorExprContext() *NullOperatorExprContext {
	var p = new(NullOperatorExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nullOperatorExpr
	return p
}

func (*NullOperatorExprContext) IsNullOperatorExprContext() {}

func NewNullOperatorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullOperatorExprContext {
	var p = new(NullOperatorExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nullOperatorExpr

	return p
}

func (s *NullOperatorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *NullOperatorExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NullOperatorExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NullOperatorExprContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *NullOperatorExprContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *NullOperatorExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *NullOperatorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullOperatorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullOperatorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitNullOperatorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NullOperatorExpr() (localctx INullOperatorExprContext) {
	localctx = NewNullOperatorExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CypherParserRULE_nullOperatorExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1068)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1069)
			p.Match(CypherParserIS)
		}
		{
			p.SetState(1070)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1071)
			p.Match(CypherParserNULL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1072)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1073)
			p.Match(CypherParserIS)
		}
		{
			p.SetState(1074)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1075)
			p.Match(CypherParserNOT)
		}
		{
			p.SetState(1076)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1077)
			p.Match(CypherParserNULL)
		}

	}

	return localctx
}

// IPropertyOrLabelsExprContext is an interface to support dynamic dispatch.
type IPropertyOrLabelsExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyOrLabelsExprContext differentiates from other interfaces.
	IsPropertyOrLabelsExprContext()
}

type PropertyOrLabelsExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyOrLabelsExprContext() *PropertyOrLabelsExprContext {
	var p = new(PropertyOrLabelsExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyOrLabelsExpr
	return p
}

func (*PropertyOrLabelsExprContext) IsPropertyOrLabelsExprContext() {}

func NewPropertyOrLabelsExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyOrLabelsExprContext {
	var p = new(PropertyOrLabelsExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyOrLabelsExpr

	return p
}

func (s *PropertyOrLabelsExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyOrLabelsExprContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PropertyOrLabelsExprContext) AllPropertyLookup() []IPropertyLookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyLookupContext)(nil)).Elem())
	var tst = make([]IPropertyLookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyLookupContext)
		}
	}

	return tst
}

func (s *PropertyOrLabelsExprContext) PropertyLookup(i int) IPropertyLookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyLookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyLookupContext)
}

func (s *PropertyOrLabelsExprContext) NodeLabels() INodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *PropertyOrLabelsExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyOrLabelsExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyOrLabelsExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyOrLabelsExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyOrLabelsExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPropertyOrLabelsExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PropertyOrLabelsExpr() (localctx IPropertyOrLabelsExprContext) {
	localctx = NewPropertyOrLabelsExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CypherParserRULE_propertyOrLabelsExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)
		p.Atom()
	}
	p.SetState(1087)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1082)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1081)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1084)
				p.PropertyLookup()
			}

		}
		p.SetState(1089)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())
	}
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1090)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1093)
			p.NodeLabels()
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomContext) Parameter() IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *AtomContext) CaseExpr() ICaseExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseExprContext)
}

func (s *AtomContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *AtomContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AtomContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AtomContext) ListComprehension() IListComprehensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListComprehensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListComprehensionContext)
}

func (s *AtomContext) PatternComprehension() IPatternComprehensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternComprehensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternComprehensionContext)
}

func (s *AtomContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *AtomContext) FilterExpr() IFilterExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterExprContext)
}

func (s *AtomContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *AtomContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *AtomContext) RelationshipsPattern() IRelationshipsPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipsPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipsPatternContext)
}

func (s *AtomContext) ParenthesizedExpr() IParenthesizedExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExprContext)
}

func (s *AtomContext) FunctionInvocation() IFunctionInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionInvocationContext)
}

func (s *AtomContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CypherParserRULE_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1096)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1097)
			p.Parameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1098)
			p.CaseExpr()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1099)
			p.Match(CypherParserCOUNT)
		}
		p.SetState(1101)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1100)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1103)
			p.Match(CypherParserT__5)
		}
		p.SetState(1105)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1104)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1107)
			p.Match(CypherParserT__4)
		}
		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1108)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1111)
			p.Match(CypherParserT__6)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1112)
			p.ListComprehension()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1113)
			p.PatternComprehension()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1114)
			p.Match(CypherParserALL)
		}
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1115)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1118)
			p.Match(CypherParserT__5)
		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1119)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1122)
			p.FilterExpr()
		}
		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1123)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1126)
			p.Match(CypherParserT__6)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1128)
			p.Match(CypherParserANY)
		}
		p.SetState(1130)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1129)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1132)
			p.Match(CypherParserT__5)
		}
		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1133)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1136)
			p.FilterExpr()
		}
		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1137)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1140)
			p.Match(CypherParserT__6)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1142)
			p.Match(CypherParserNONE)
		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1143)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1146)
			p.Match(CypherParserT__5)
		}
		p.SetState(1148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1147)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1150)
			p.FilterExpr()
		}
		p.SetState(1152)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1151)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1154)
			p.Match(CypherParserT__6)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1156)
			p.Match(CypherParserSINGLE)
		}
		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1157)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1160)
			p.Match(CypherParserT__5)
		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1161)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1164)
			p.FilterExpr()
		}
		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1165)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1168)
			p.Match(CypherParserT__6)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1170)
			p.RelationshipsPattern()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1171)
			p.ParenthesizedExpr()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1172)
			p.FunctionInvocation()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1173)
			p.Variable()
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CypherParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *LiteralContext) MapLiteral() IMapLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *LiteralContext) ListLiteral() IListLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CypherParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1182)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1176)
			p.NumberLiteral()
		}

	case CypherParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1177)
			p.Match(CypherParserStringLiteral)
		}

	case CypherParserTRUE, CypherParserFALSE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1178)
			p.BooleanLiteral()
		}

	case CypherParserNULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1179)
			p.Match(CypherParserNULL)
		}

	case CypherParserT__23:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1180)
			p.MapLiteral()
		}

	case CypherParserT__7:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1181)
			p.ListLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CypherParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1184)
	_la = p.GetTokenStream().LA(1)

	if !(_la == CypherParserTRUE || _la == CypherParserFALSE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IListLiteralContext is an interface to support dynamic dispatch.
type IListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListLiteralContext differentiates from other interfaces.
	IsListLiteralContext()
}

type ListLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListLiteralContext() *ListLiteralContext {
	var p = new(ListLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_listLiteral
	return p
}

func (*ListLiteralContext) IsListLiteralContext() {}

func NewListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListLiteralContext {
	var p = new(ListLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listLiteral

	return p
}

func (s *ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ListLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ListLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ListLiteralContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ListLiteralContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitListLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ListLiteral() (localctx IListLiteralContext) {
	localctx = NewListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CypherParserRULE_listLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1186)
		p.Match(CypherParserT__7)
	}
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1187)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__5)|(1<<CypherParserT__7)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__23)|(1<<CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-82)&-(0x1f+1)) == 0 && ((1<<uint((_la-82)))&((1<<(CypherParserNULL-82))|(1<<(CypherParserCOUNT-82))|(1<<(CypherParserANY-82))|(1<<(CypherParserNONE-82))|(1<<(CypherParserSINGLE-82))|(1<<(CypherParserTRUE-82))|(1<<(CypherParserFALSE-82))|(1<<(CypherParserEXISTS-82))|(1<<(CypherParserCASE-82))|(1<<(CypherParserStringLiteral-82))|(1<<(CypherParserHexInteger-82))|(1<<(CypherParserDecimalInteger-82))|(1<<(CypherParserOctalInteger-82))|(1<<(CypherParserHexLetter-82))|(1<<(CypherParserExponentDecimalReal-82))|(1<<(CypherParserRegularDecimalReal-82)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0) {
		{
			p.SetState(1190)
			p.Expr()
		}
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1191)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__1 {
			{
				p.SetState(1194)
				p.Match(CypherParserT__1)
			}
			p.SetState(1196)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1195)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1198)
				p.Expr()
			}
			p.SetState(1200)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1199)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(1206)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1209)
		p.Match(CypherParserT__8)
	}

	return localctx
}

// IPartialComparisonExprContext is an interface to support dynamic dispatch.
type IPartialComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialComparisonExprContext differentiates from other interfaces.
	IsPartialComparisonExprContext()
}

type PartialComparisonExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialComparisonExprContext() *PartialComparisonExprContext {
	var p = new(PartialComparisonExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_partialComparisonExpr
	return p
}

func (*PartialComparisonExprContext) IsPartialComparisonExprContext() {}

func NewPartialComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialComparisonExprContext {
	var p = new(PartialComparisonExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_partialComparisonExpr

	return p
}

func (s *PartialComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialComparisonExprContext) AddOrSubtractExpr() IAddOrSubtractExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOrSubtractExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddOrSubtractExprContext)
}

func (s *PartialComparisonExprContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PartialComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPartialComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PartialComparisonExpr() (localctx IPartialComparisonExprContext) {
	localctx = NewPartialComparisonExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CypherParserRULE_partialComparisonExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1241)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1211)
			p.Match(CypherParserT__2)
		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1212)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1215)
			p.AddOrSubtractExpr()
		}

	case CypherParserT__17:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1216)
			p.Match(CypherParserT__17)
		}
		p.SetState(1218)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1217)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1220)
			p.AddOrSubtractExpr()
		}

	case CypherParserT__18:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1221)
			p.Match(CypherParserT__18)
		}
		p.SetState(1223)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1222)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1225)
			p.AddOrSubtractExpr()
		}

	case CypherParserT__19:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1226)
			p.Match(CypherParserT__19)
		}
		p.SetState(1228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1227)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1230)
			p.AddOrSubtractExpr()
		}

	case CypherParserT__20:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1231)
			p.Match(CypherParserT__20)
		}
		p.SetState(1233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1232)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1235)
			p.AddOrSubtractExpr()
		}

	case CypherParserT__21:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1236)
			p.Match(CypherParserT__21)
		}
		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1237)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1240)
			p.AddOrSubtractExpr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParenthesizedExprContext is an interface to support dynamic dispatch.
type IParenthesizedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedExprContext differentiates from other interfaces.
	IsParenthesizedExprContext()
}

type ParenthesizedExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExprContext() *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_parenthesizedExpr
	return p
}

func (*ParenthesizedExprContext) IsParenthesizedExprContext() {}

func NewParenthesizedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parenthesizedExpr

	return p
}

func (s *ParenthesizedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParenthesizedExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ParenthesizedExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ParenthesizedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitParenthesizedExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ParenthesizedExpr() (localctx IParenthesizedExprContext) {
	localctx = NewParenthesizedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CypherParserRULE_parenthesizedExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1243)
		p.Match(CypherParserT__5)
	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1244)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1247)
		p.Expr()
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1248)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1251)
		p.Match(CypherParserT__6)
	}

	return localctx
}

// IRelationshipsPatternContext is an interface to support dynamic dispatch.
type IRelationshipsPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipsPatternContext differentiates from other interfaces.
	IsRelationshipsPatternContext()
}

type RelationshipsPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipsPatternContext() *RelationshipsPatternContext {
	var p = new(RelationshipsPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipsPattern
	return p
}

func (*RelationshipsPatternContext) IsRelationshipsPatternContext() {}

func NewRelationshipsPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipsPatternContext {
	var p = new(RelationshipsPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipsPattern

	return p
}

func (s *RelationshipsPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipsPatternContext) NodePattern() INodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *RelationshipsPatternContext) AllPatternElementChain() []IPatternElementChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatternElementChainContext)(nil)).Elem())
	var tst = make([]IPatternElementChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatternElementChainContext)
		}
	}

	return tst
}

func (s *RelationshipsPatternContext) PatternElementChain(i int) IPatternElementChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternElementChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatternElementChainContext)
}

func (s *RelationshipsPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipsPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipsPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipsPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipsPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRelationshipsPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RelationshipsPattern() (localctx IRelationshipsPatternContext) {
	localctx = NewRelationshipsPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CypherParserRULE_relationshipsPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1253)
		p.NodePattern()
	}
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1255)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1254)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1257)
				p.PatternElementChain()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1260)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext())
	}

	return localctx
}

// IFilterExprContext is an interface to support dynamic dispatch.
type IFilterExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterExprContext differentiates from other interfaces.
	IsFilterExprContext()
}

type FilterExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterExprContext() *FilterExprContext {
	var p = new(FilterExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_filterExpr
	return p
}

func (*FilterExprContext) IsFilterExprContext() {}

func NewFilterExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterExprContext {
	var p = new(FilterExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_filterExpr

	return p
}

func (s *FilterExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterExprContext) IdInColl() IIdInCollContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdInCollContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdInCollContext)
}

func (s *FilterExprContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *FilterExprContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *FilterExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitFilterExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) FilterExpr() (localctx IFilterExprContext) {
	localctx = NewFilterExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CypherParserRULE_filterExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1262)
		p.IdInColl()
	}
	p.SetState(1267)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext()) == 1 {
		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1263)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1266)
			p.WhereClause()
		}

	}

	return localctx
}

// IIdInCollContext is an interface to support dynamic dispatch.
type IIdInCollContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdInCollContext differentiates from other interfaces.
	IsIdInCollContext()
}

type IdInCollContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdInCollContext() *IdInCollContext {
	var p = new(IdInCollContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_idInColl
	return p
}

func (*IdInCollContext) IsIdInCollContext() {}

func NewIdInCollContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdInCollContext {
	var p = new(IdInCollContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_idInColl

	return p
}

func (s *IdInCollContext) GetParser() antlr.Parser { return s.parser }

func (s *IdInCollContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *IdInCollContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *IdInCollContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *IdInCollContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *IdInCollContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IdInCollContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdInCollContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdInCollContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitIdInColl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) IdInColl() (localctx IIdInCollContext) {
	localctx = NewIdInCollContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CypherParserRULE_idInColl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1269)
		p.Variable()
	}
	{
		p.SetState(1270)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1271)
		p.Match(CypherParserIN)
	}
	{
		p.SetState(1272)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1273)
		p.Expr()
	}

	return localctx
}

// IFunctionInvocationContext is an interface to support dynamic dispatch.
type IFunctionInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionInvocationContext differentiates from other interfaces.
	IsFunctionInvocationContext()
}

type FunctionInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionInvocationContext() *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_functionInvocation
	return p
}

func (*FunctionInvocationContext) IsFunctionInvocationContext() {}

func NewFunctionInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_functionInvocation

	return p
}

func (s *FunctionInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionInvocationContext) FunctionName() IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *FunctionInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *FunctionInvocationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *FunctionInvocationContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *FunctionInvocationContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *FunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitFunctionInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) FunctionInvocation() (localctx IFunctionInvocationContext) {
	localctx = NewFunctionInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CypherParserRULE_functionInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1275)
		p.FunctionName()
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1276)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1279)
		p.Match(CypherParserT__5)
	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1280)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1287)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDISTINCT {
		{
			p.SetState(1283)
			p.Match(CypherParserDISTINCT)
		}
		p.SetState(1285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1284)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(1306)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__5)|(1<<CypherParserT__7)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__23)|(1<<CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-82)&-(0x1f+1)) == 0 && ((1<<uint((_la-82)))&((1<<(CypherParserNULL-82))|(1<<(CypherParserCOUNT-82))|(1<<(CypherParserANY-82))|(1<<(CypherParserNONE-82))|(1<<(CypherParserSINGLE-82))|(1<<(CypherParserTRUE-82))|(1<<(CypherParserFALSE-82))|(1<<(CypherParserEXISTS-82))|(1<<(CypherParserCASE-82))|(1<<(CypherParserStringLiteral-82))|(1<<(CypherParserHexInteger-82))|(1<<(CypherParserDecimalInteger-82))|(1<<(CypherParserOctalInteger-82))|(1<<(CypherParserHexLetter-82))|(1<<(CypherParserExponentDecimalReal-82))|(1<<(CypherParserRegularDecimalReal-82)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0) {
		{
			p.SetState(1289)
			p.Expr()
		}
		p.SetState(1291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1290)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__1 {
			{
				p.SetState(1293)
				p.Match(CypherParserT__1)
			}
			p.SetState(1295)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1294)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1297)
				p.Expr()
			}
			p.SetState(1299)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1298)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(1305)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1308)
		p.Match(CypherParserT__6)
	}

	return localctx
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_functionName
	return p
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) Namespace() INamespaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *FunctionNameContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *FunctionNameContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CypherParserRULE_functionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1314)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1310)
			p.Namespace()
		}
		{
			p.SetState(1311)
			p.SymbolicName()
		}

	case CypherParserEXISTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1313)
			p.Match(CypherParserEXISTS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExplicitProcedureInvocationContext is an interface to support dynamic dispatch.
type IExplicitProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitProcedureInvocationContext differentiates from other interfaces.
	IsExplicitProcedureInvocationContext()
}

type ExplicitProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitProcedureInvocationContext() *ExplicitProcedureInvocationContext {
	var p = new(ExplicitProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_explicitProcedureInvocation
	return p
}

func (*ExplicitProcedureInvocationContext) IsExplicitProcedureInvocationContext() {}

func NewExplicitProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitProcedureInvocationContext {
	var p = new(ExplicitProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_explicitProcedureInvocation

	return p
}

func (s *ExplicitProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitProcedureInvocationContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *ExplicitProcedureInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ExplicitProcedureInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ExplicitProcedureInvocationContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExplicitProcedureInvocationContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExplicitProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitProcedureInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitExplicitProcedureInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ExplicitProcedureInvocation() (localctx IExplicitProcedureInvocationContext) {
	localctx = NewExplicitProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CypherParserRULE_explicitProcedureInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1316)
		p.ProcedureName()
	}
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1317)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1320)
		p.Match(CypherParserT__5)
	}
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1321)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__5)|(1<<CypherParserT__7)|(1<<CypherParserT__12)|(1<<CypherParserT__13)|(1<<CypherParserT__23)|(1<<CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-82)&-(0x1f+1)) == 0 && ((1<<uint((_la-82)))&((1<<(CypherParserNULL-82))|(1<<(CypherParserCOUNT-82))|(1<<(CypherParserANY-82))|(1<<(CypherParserNONE-82))|(1<<(CypherParserSINGLE-82))|(1<<(CypherParserTRUE-82))|(1<<(CypherParserFALSE-82))|(1<<(CypherParserEXISTS-82))|(1<<(CypherParserCASE-82))|(1<<(CypherParserStringLiteral-82))|(1<<(CypherParserHexInteger-82))|(1<<(CypherParserDecimalInteger-82))|(1<<(CypherParserOctalInteger-82))|(1<<(CypherParserHexLetter-82))|(1<<(CypherParserExponentDecimalReal-82))|(1<<(CypherParserRegularDecimalReal-82)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0) {
		{
			p.SetState(1324)
			p.Expr()
		}
		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1325)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__1 {
			{
				p.SetState(1328)
				p.Match(CypherParserT__1)
			}
			p.SetState(1330)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1329)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1332)
				p.Expr()
			}
			p.SetState(1334)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1333)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(1340)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1343)
		p.Match(CypherParserT__6)
	}

	return localctx
}

// IImplicitProcedureInvocationContext is an interface to support dynamic dispatch.
type IImplicitProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplicitProcedureInvocationContext differentiates from other interfaces.
	IsImplicitProcedureInvocationContext()
}

type ImplicitProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplicitProcedureInvocationContext() *ImplicitProcedureInvocationContext {
	var p = new(ImplicitProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_implicitProcedureInvocation
	return p
}

func (*ImplicitProcedureInvocationContext) IsImplicitProcedureInvocationContext() {}

func NewImplicitProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplicitProcedureInvocationContext {
	var p = new(ImplicitProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_implicitProcedureInvocation

	return p
}

func (s *ImplicitProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplicitProcedureInvocationContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *ImplicitProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplicitProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplicitProcedureInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitImplicitProcedureInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ImplicitProcedureInvocation() (localctx IImplicitProcedureInvocationContext) {
	localctx = NewImplicitProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CypherParserRULE_implicitProcedureInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1345)
		p.ProcedureName()
	}

	return localctx
}

// IProcedureResultFieldContext is an interface to support dynamic dispatch.
type IProcedureResultFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureResultFieldContext differentiates from other interfaces.
	IsProcedureResultFieldContext()
}

type ProcedureResultFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureResultFieldContext() *ProcedureResultFieldContext {
	var p = new(ProcedureResultFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureResultField
	return p
}

func (*ProcedureResultFieldContext) IsProcedureResultFieldContext() {}

func NewProcedureResultFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureResultFieldContext {
	var p = new(ProcedureResultFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureResultField

	return p
}

func (s *ProcedureResultFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureResultFieldContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ProcedureResultFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureResultFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureResultFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitProcedureResultField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ProcedureResultField() (localctx IProcedureResultFieldContext) {
	localctx = NewProcedureResultFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CypherParserRULE_procedureResultField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		p.SymbolicName()
	}

	return localctx
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureName
	return p
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) Namespace() INamespaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *ProcedureNameContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitProcedureName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ProcedureName() (localctx IProcedureNameContext) {
	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CypherParserRULE_procedureName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Namespace()
	}
	{
		p.SetState(1350)
		p.SymbolicName()
	}

	return localctx
}

// INamespaceContext is an interface to support dynamic dispatch.
type INamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceContext differentiates from other interfaces.
	IsNamespaceContext()
}

type NamespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceContext() *NamespaceContext {
	var p = new(NamespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_namespace
	return p
}

func (*NamespaceContext) IsNamespaceContext() {}

func NewNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceContext {
	var p = new(NamespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_namespace

	return p
}

func (s *NamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceContext) AllSymbolicName() []ISymbolicNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem())
	var tst = make([]ISymbolicNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicNameContext)
		}
	}

	return tst
}

func (s *NamespaceContext) SymbolicName(i int) ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *NamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitNamespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Namespace() (localctx INamespaceContext) {
	localctx = NewNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CypherParserRULE_namespace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1352)
				p.SymbolicName()
			}
			{
				p.SetState(1353)
				p.Match(CypherParserT__22)
			}

		}
		p.SetState(1359)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext())
	}

	return localctx
}

// IListComprehensionContext is an interface to support dynamic dispatch.
type IListComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListComprehensionContext differentiates from other interfaces.
	IsListComprehensionContext()
}

type ListComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListComprehensionContext() *ListComprehensionContext {
	var p = new(ListComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_listComprehension
	return p
}

func (*ListComprehensionContext) IsListComprehensionContext() {}

func NewListComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListComprehensionContext {
	var p = new(ListComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listComprehension

	return p
}

func (s *ListComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListComprehensionContext) FilterExpr() IFilterExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterExprContext)
}

func (s *ListComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ListComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ListComprehensionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ListComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListComprehensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitListComprehension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ListComprehension() (localctx IListComprehensionContext) {
	localctx = NewListComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CypherParserRULE_listComprehension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1360)
		p.Match(CypherParserT__7)
	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1361)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1364)
		p.FilterExpr()
	}
	p.SetState(1373)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1365)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1368)
			p.Match(CypherParserT__10)
		}
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1369)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1372)
			p.Expr()
		}

	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1375)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1378)
		p.Match(CypherParserT__8)
	}

	return localctx
}

// IPatternComprehensionContext is an interface to support dynamic dispatch.
type IPatternComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternComprehensionContext differentiates from other interfaces.
	IsPatternComprehensionContext()
}

type PatternComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternComprehensionContext() *PatternComprehensionContext {
	var p = new(PatternComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternComprehension
	return p
}

func (*PatternComprehensionContext) IsPatternComprehensionContext() {}

func NewPatternComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternComprehensionContext {
	var p = new(PatternComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternComprehension

	return p
}

func (s *PatternComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternComprehensionContext) RelationshipsPattern() IRelationshipsPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipsPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipsPatternContext)
}

func (s *PatternComprehensionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *PatternComprehensionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PatternComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternComprehensionContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PatternComprehensionContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *PatternComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternComprehensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPatternComprehension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PatternComprehension() (localctx IPatternComprehensionContext) {
	localctx = NewPatternComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CypherParserRULE_patternComprehension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1380)
		p.Match(CypherParserT__7)
	}
	p.SetState(1382)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1381)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserCOUNT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserHexLetter-83)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0) {
		{
			p.SetState(1384)
			p.Variable()
		}
		p.SetState(1386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1385)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1388)
			p.Match(CypherParserT__2)
		}
		p.SetState(1390)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1389)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(1394)
		p.RelationshipsPattern()
	}
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1395)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(1398)
			p.Match(CypherParserWHERE)
		}
		p.SetState(1400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1399)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1402)
			p.Expr()
		}
		p.SetState(1404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1403)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(1408)
		p.Match(CypherParserT__10)
	}
	p.SetState(1410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1409)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1412)
		p.Expr()
	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1413)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1416)
		p.Match(CypherParserT__8)
	}

	return localctx
}

// IPropertyLookupContext is an interface to support dynamic dispatch.
type IPropertyLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyLookupContext differentiates from other interfaces.
	IsPropertyLookupContext()
}

type PropertyLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyLookupContext() *PropertyLookupContext {
	var p = new(PropertyLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyLookup
	return p
}

func (*PropertyLookupContext) IsPropertyLookupContext() {}

func NewPropertyLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyLookupContext {
	var p = new(PropertyLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyLookup

	return p
}

func (s *PropertyLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyLookupContext) PropertyKeyName() IPropertyKeyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyKeyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyNameContext)
}

func (s *PropertyLookupContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PropertyLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyLookupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPropertyLookup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PropertyLookup() (localctx IPropertyLookupContext) {
	localctx = NewPropertyLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CypherParserRULE_propertyLookup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1418)
		p.Match(CypherParserT__22)
	}
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1419)
			p.Match(CypherParserSP)
		}

	}

	{
		p.SetState(1422)
		p.PropertyKeyName()
	}

	return localctx
}

// ICaseExprContext is an interface to support dynamic dispatch.
type ICaseExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseExprContext differentiates from other interfaces.
	IsCaseExprContext()
}

type CaseExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExprContext() *CaseExprContext {
	var p = new(CaseExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_caseExpr
	return p
}

func (*CaseExprContext) IsCaseExprContext() {}

func NewCaseExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExprContext {
	var p = new(CaseExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_caseExpr

	return p
}

func (s *CaseExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExprContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *CaseExprContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *CaseExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *CaseExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CaseExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CaseExprContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *CaseExprContext) AllCaseAlternatives() []ICaseAlternativesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseAlternativesContext)(nil)).Elem())
	var tst = make([]ICaseAlternativesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseAlternativesContext)
		}
	}

	return tst
}

func (s *CaseExprContext) CaseAlternatives(i int) ICaseAlternativesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseAlternativesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseAlternativesContext)
}

func (s *CaseExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitCaseExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) CaseExpr() (localctx ICaseExprContext) {
	localctx = NewCaseExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CypherParserRULE_caseExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1424)
			p.Match(CypherParserCASE)
		}
		p.SetState(1429)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(1426)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1425)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1428)
					p.CaseAlternatives()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1431)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 258, p.GetParserRuleContext())
		}

	case 2:
		{
			p.SetState(1433)
			p.Match(CypherParserCASE)
		}
		p.SetState(1435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1434)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1437)
			p.Expr()
		}
		p.SetState(1442)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(1439)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1438)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1441)
					p.CaseAlternatives()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1444)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 261, p.GetParserRuleContext())
		}

	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext()) == 1 {
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1448)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1451)
			p.Match(CypherParserELSE)
		}
		p.SetState(1453)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1452)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1455)
			p.Expr()
		}

	}
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1458)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1461)
		p.Match(CypherParserEND)
	}

	return localctx
}

// ICaseAlternativesContext is an interface to support dynamic dispatch.
type ICaseAlternativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseAlternativesContext differentiates from other interfaces.
	IsCaseAlternativesContext()
}

type CaseAlternativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseAlternativesContext() *CaseAlternativesContext {
	var p = new(CaseAlternativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_caseAlternatives
	return p
}

func (*CaseAlternativesContext) IsCaseAlternativesContext() {}

func NewCaseAlternativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseAlternativesContext {
	var p = new(CaseAlternativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_caseAlternatives

	return p
}

func (s *CaseAlternativesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseAlternativesContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *CaseAlternativesContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *CaseAlternativesContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseAlternativesContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *CaseAlternativesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CaseAlternativesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CaseAlternativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseAlternativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseAlternativesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitCaseAlternatives(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) CaseAlternatives() (localctx ICaseAlternativesContext) {
	localctx = NewCaseAlternativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CypherParserRULE_caseAlternatives)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1463)
		p.Match(CypherParserWHEN)
	}
	p.SetState(1465)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1464)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1467)
		p.Expr()
	}
	p.SetState(1469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1468)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1471)
		p.Match(CypherParserTHEN)
	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1472)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1475)
		p.Expr()
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CypherParserRULE_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		p.SymbolicName()
	}

	return localctx
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_numberLiteral
	return p
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) DoubleLiteral() IDoubleLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoubleLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoubleLiteralContext)
}

func (s *NumberLiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitNumberLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CypherParserRULE_numberLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1481)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1479)
			p.DoubleLiteral()
		}

	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1480)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mapLiteral
	return p
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MapLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MapLiteralContext) AllPropertyKeyName() []IPropertyKeyNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyKeyNameContext)(nil)).Elem())
	var tst = make([]IPropertyKeyNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyKeyNameContext)
		}
	}

	return tst
}

func (s *MapLiteralContext) PropertyKeyName(i int) IPropertyKeyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyKeyNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyNameContext)
}

func (s *MapLiteralContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *MapLiteralContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitMapLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CypherParserRULE_mapLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1483)
		p.Match(CypherParserT__23)
	}
	p.SetState(1485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1484)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(CypherParserUNION-46))|(1<<(CypherParserALL-46))|(1<<(CypherParserOPTIONAL-46))|(1<<(CypherParserMATCH-46))|(1<<(CypherParserUNWIND-46))|(1<<(CypherParserAS-46))|(1<<(CypherParserMERGE-46))|(1<<(CypherParserON-46))|(1<<(CypherParserCREATE-46))|(1<<(CypherParserSET-46))|(1<<(CypherParserDETACH-46))|(1<<(CypherParserDELETE-46))|(1<<(CypherParserREMOVE-46))|(1<<(CypherParserWITH-46))|(1<<(CypherParserDISTINCT-46))|(1<<(CypherParserRETURN-46))|(1<<(CypherParserORDER-46))|(1<<(CypherParserBY-46))|(1<<(CypherParserL_SKIP-46))|(1<<(CypherParserLIMIT-46))|(1<<(CypherParserASCENDING-46))|(1<<(CypherParserASC-46))|(1<<(CypherParserDESCENDING-46))|(1<<(CypherParserDESC-46))|(1<<(CypherParserWHERE-46))|(1<<(CypherParserOR-46))|(1<<(CypherParserXOR-46))|(1<<(CypherParserAND-46))|(1<<(CypherParserNOT-46))|(1<<(CypherParserIN-46)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(CypherParserSTARTS-78))|(1<<(CypherParserENDS-78))|(1<<(CypherParserCONTAINS-78))|(1<<(CypherParserIS-78))|(1<<(CypherParserNULL-78))|(1<<(CypherParserCOUNT-78))|(1<<(CypherParserANY-78))|(1<<(CypherParserNONE-78))|(1<<(CypherParserSINGLE-78))|(1<<(CypherParserTRUE-78))|(1<<(CypherParserFALSE-78))|(1<<(CypherParserEXISTS-78))|(1<<(CypherParserCASE-78))|(1<<(CypherParserELSE-78))|(1<<(CypherParserEND-78))|(1<<(CypherParserWHEN-78))|(1<<(CypherParserTHEN-78))|(1<<(CypherParserHexLetter-78))|(1<<(CypherParserCONSTRAINT-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(CypherParserDO-110))|(1<<(CypherParserFOR-110))|(1<<(CypherParserREQUIRE-110))|(1<<(CypherParserUNIQUE-110))|(1<<(CypherParserMANDATORY-110))|(1<<(CypherParserSCALAR-110))|(1<<(CypherParserOF-110))|(1<<(CypherParserADD-110))|(1<<(CypherParserDROP-110))|(1<<(CypherParserFILTER-110))|(1<<(CypherParserEXTRACT-110))|(1<<(CypherParserUnescapedSymbolicName-110))|(1<<(CypherParserEscapedSymbolicName-110)))) != 0) {
		{
			p.SetState(1487)
			p.PropertyKeyName()
		}
		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1488)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1491)
			p.Match(CypherParserT__9)
		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1492)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1495)
			p.Expr()
		}
		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1496)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1517)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__1 {
			{
				p.SetState(1499)
				p.Match(CypherParserT__1)
			}
			p.SetState(1501)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1500)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1503)
				p.PropertyKeyName()
			}
			p.SetState(1505)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1504)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1507)
				p.Match(CypherParserT__9)
			}
			p.SetState(1509)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1508)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1511)
				p.Expr()
			}
			p.SetState(1513)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1512)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(1519)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1522)
		p.Match(CypherParserT__24)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ParameterContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserDecimalInteger, 0)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CypherParserRULE_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		p.Match(CypherParserT__25)
	}
	p.SetState(1527)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		{
			p.SetState(1525)
			p.SymbolicName()
		}

	case CypherParserDecimalInteger:
		{
			p.SetState(1526)
			p.Match(CypherParserDecimalInteger)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertyExprContext is an interface to support dynamic dispatch.
type IPropertyExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyExprContext differentiates from other interfaces.
	IsPropertyExprContext()
}

type PropertyExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyExprContext() *PropertyExprContext {
	var p = new(PropertyExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyExpr
	return p
}

func (*PropertyExprContext) IsPropertyExprContext() {}

func NewPropertyExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyExprContext {
	var p = new(PropertyExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyExpr

	return p
}

func (s *PropertyExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyExprContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PropertyExprContext) AllPropertyLookup() []IPropertyLookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyLookupContext)(nil)).Elem())
	var tst = make([]IPropertyLookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyLookupContext)
		}
	}

	return tst
}

func (s *PropertyExprContext) PropertyLookup(i int) IPropertyLookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyLookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyLookupContext)
}

func (s *PropertyExprContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyExprContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPropertyExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PropertyExpr() (localctx IPropertyExprContext) {
	localctx = NewPropertyExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CypherParserRULE_propertyExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1529)
		p.Atom()
	}
	p.SetState(1534)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1531)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1530)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1533)
				p.PropertyLookup()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1536)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 283, p.GetParserRuleContext())
	}

	return localctx
}

// IPropertyKeyNameContext is an interface to support dynamic dispatch.
type IPropertyKeyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyKeyNameContext differentiates from other interfaces.
	IsPropertyKeyNameContext()
}

type PropertyKeyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyNameContext() *PropertyKeyNameContext {
	var p = new(PropertyKeyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyKeyName
	return p
}

func (*PropertyKeyNameContext) IsPropertyKeyNameContext() {}

func NewPropertyKeyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyNameContext {
	var p = new(PropertyKeyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyKeyName

	return p
}

func (s *PropertyKeyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *PropertyKeyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitPropertyKeyName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) PropertyKeyName() (localctx IPropertyKeyNameContext) {
	localctx = NewPropertyKeyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CypherParserRULE_propertyKeyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1538)
		p.SchemaName()
	}

	return localctx
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_integerLiteral
	return p
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) HexInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserHexInteger, 0)
}

func (s *IntegerLiteralContext) OctalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserOctalInteger, 0)
}

func (s *IntegerLiteralContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserDecimalInteger, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CypherParserRULE_integerLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1540)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(CypherParserHexInteger-97))|(1<<(CypherParserDecimalInteger-97))|(1<<(CypherParserOctalInteger-97)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDoubleLiteralContext is an interface to support dynamic dispatch.
type IDoubleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoubleLiteralContext differentiates from other interfaces.
	IsDoubleLiteralContext()
}

type DoubleLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleLiteralContext() *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_doubleLiteral
	return p
}

func (*DoubleLiteralContext) IsDoubleLiteralContext() {}

func NewDoubleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_doubleLiteral

	return p
}

func (s *DoubleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleLiteralContext) ExponentDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserExponentDecimalReal, 0)
}

func (s *DoubleLiteralContext) RegularDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserRegularDecimalReal, 0)
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitDoubleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) DoubleLiteral() (localctx IDoubleLiteralContext) {
	localctx = NewDoubleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CypherParserRULE_doubleLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1542)
	_la = p.GetTokenStream().LA(1)

	if !(_la == CypherParserExponentDecimalReal || _la == CypherParserRegularDecimalReal) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISchemaNameContext is an interface to support dynamic dispatch.
type ISchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaNameContext differentiates from other interfaces.
	IsSchemaNameContext()
}

type SchemaNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaNameContext() *SchemaNameContext {
	var p = new(SchemaNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_schemaName
	return p
}

func (*SchemaNameContext) IsSchemaNameContext() {}

func NewSchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaNameContext {
	var p = new(SchemaNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_schemaName

	return p
}

func (s *SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaNameContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *SchemaNameContext) ReservedWord() IReservedWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReservedWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitSchemaName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SchemaName() (localctx ISchemaNameContext) {
	localctx = NewSchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CypherParserRULE_schemaName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1546)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1544)
			p.SymbolicName()
		}

	case CypherParserUNION, CypherParserALL, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserAS, CypherParserMERGE, CypherParserON, CypherParserCREATE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserWITH, CypherParserDISTINCT, CypherParserRETURN, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserWHERE, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserIN, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserIS, CypherParserNULL, CypherParserTRUE, CypherParserFALSE, CypherParserEXISTS, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserCONSTRAINT, CypherParserDO, CypherParserFOR, CypherParserREQUIRE, CypherParserUNIQUE, CypherParserMANDATORY, CypherParserSCALAR, CypherParserOF, CypherParserADD, CypherParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1545)
			p.ReservedWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_reservedWord
	return p
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *ReservedWordContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *ReservedWordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *ReservedWordContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *ReservedWordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *ReservedWordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *ReservedWordContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *ReservedWordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *ReservedWordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *ReservedWordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *ReservedWordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *ReservedWordContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *ReservedWordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *ReservedWordContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *ReservedWordContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *ReservedWordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *ReservedWordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *ReservedWordContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *ReservedWordContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *ReservedWordContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(CypherParserL_SKIP, 0)
}

func (s *ReservedWordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *ReservedWordContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *ReservedWordContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *ReservedWordContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *ReservedWordContext) AND() antlr.TerminalNode {
	return s.GetToken(CypherParserAND, 0)
}

func (s *ReservedWordContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *ReservedWordContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, 0)
}

func (s *ReservedWordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *ReservedWordContext) ENDS() antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, 0)
}

func (s *ReservedWordContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *ReservedWordContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *ReservedWordContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *ReservedWordContext) OR() antlr.TerminalNode {
	return s.GetToken(CypherParserOR, 0)
}

func (s *ReservedWordContext) STARTS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, 0)
}

func (s *ReservedWordContext) XOR() antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, 0)
}

func (s *ReservedWordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *ReservedWordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *ReservedWordContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *ReservedWordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *ReservedWordContext) DO() antlr.TerminalNode {
	return s.GetToken(CypherParserDO, 0)
}

func (s *ReservedWordContext) FOR() antlr.TerminalNode {
	return s.GetToken(CypherParserFOR, 0)
}

func (s *ReservedWordContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(CypherParserREQUIRE, 0)
}

func (s *ReservedWordContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(CypherParserUNIQUE, 0)
}

func (s *ReservedWordContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *ReservedWordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *ReservedWordContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *ReservedWordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *ReservedWordContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *ReservedWordContext) MANDATORY() antlr.TerminalNode {
	return s.GetToken(CypherParserMANDATORY, 0)
}

func (s *ReservedWordContext) SCALAR() antlr.TerminalNode {
	return s.GetToken(CypherParserSCALAR, 0)
}

func (s *ReservedWordContext) OF() antlr.TerminalNode {
	return s.GetToken(CypherParserOF, 0)
}

func (s *ReservedWordContext) ADD() antlr.TerminalNode {
	return s.GetToken(CypherParserADD, 0)
}

func (s *ReservedWordContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CypherParserRULE_reservedWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1548)
	_la = p.GetTokenStream().LA(1)

	if !((((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(CypherParserUNION-46))|(1<<(CypherParserALL-46))|(1<<(CypherParserOPTIONAL-46))|(1<<(CypherParserMATCH-46))|(1<<(CypherParserUNWIND-46))|(1<<(CypherParserAS-46))|(1<<(CypherParserMERGE-46))|(1<<(CypherParserON-46))|(1<<(CypherParserCREATE-46))|(1<<(CypherParserSET-46))|(1<<(CypherParserDETACH-46))|(1<<(CypherParserDELETE-46))|(1<<(CypherParserREMOVE-46))|(1<<(CypherParserWITH-46))|(1<<(CypherParserDISTINCT-46))|(1<<(CypherParserRETURN-46))|(1<<(CypherParserORDER-46))|(1<<(CypherParserBY-46))|(1<<(CypherParserL_SKIP-46))|(1<<(CypherParserLIMIT-46))|(1<<(CypherParserASCENDING-46))|(1<<(CypherParserASC-46))|(1<<(CypherParserDESCENDING-46))|(1<<(CypherParserDESC-46))|(1<<(CypherParserWHERE-46))|(1<<(CypherParserOR-46))|(1<<(CypherParserXOR-46))|(1<<(CypherParserAND-46))|(1<<(CypherParserNOT-46))|(1<<(CypherParserIN-46)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(CypherParserSTARTS-78))|(1<<(CypherParserENDS-78))|(1<<(CypherParserCONTAINS-78))|(1<<(CypherParserIS-78))|(1<<(CypherParserNULL-78))|(1<<(CypherParserTRUE-78))|(1<<(CypherParserFALSE-78))|(1<<(CypherParserEXISTS-78))|(1<<(CypherParserCASE-78))|(1<<(CypherParserELSE-78))|(1<<(CypherParserEND-78))|(1<<(CypherParserWHEN-78))|(1<<(CypherParserTHEN-78))|(1<<(CypherParserCONSTRAINT-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(CypherParserDO-110))|(1<<(CypherParserFOR-110))|(1<<(CypherParserREQUIRE-110))|(1<<(CypherParserUNIQUE-110))|(1<<(CypherParserMANDATORY-110))|(1<<(CypherParserSCALAR-110))|(1<<(CypherParserOF-110))|(1<<(CypherParserADD-110))|(1<<(CypherParserDROP-110)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISymbolicNameContext is an interface to support dynamic dispatch.
type ISymbolicNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicNameContext differentiates from other interfaces.
	IsSymbolicNameContext()
}

type SymbolicNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicNameContext() *SymbolicNameContext {
	var p = new(SymbolicNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_symbolicName
	return p
}

func (*SymbolicNameContext) IsSymbolicNameContext() {}

func NewSymbolicNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicNameContext {
	var p = new(SymbolicNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_symbolicName

	return p
}

func (s *SymbolicNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicNameContext) UnescapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserUnescapedSymbolicName, 0)
}

func (s *SymbolicNameContext) EscapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserEscapedSymbolicName, 0)
}

func (s *SymbolicNameContext) HexLetter() antlr.TerminalNode {
	return s.GetToken(CypherParserHexLetter, 0)
}

func (s *SymbolicNameContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *SymbolicNameContext) FILTER() antlr.TerminalNode {
	return s.GetToken(CypherParserFILTER, 0)
}

func (s *SymbolicNameContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(CypherParserEXTRACT, 0)
}

func (s *SymbolicNameContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *SymbolicNameContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *SymbolicNameContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *SymbolicNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitSymbolicName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) SymbolicName() (localctx ISymbolicNameContext) {
	localctx = NewSymbolicNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CypherParserRULE_symbolicName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1550)
	_la = p.GetTokenStream().LA(1)

	if !((((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserCOUNT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserHexLetter-83)))) != 0) || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(CypherParserFILTER-119))|(1<<(CypherParserEXTRACT-119))|(1<<(CypherParserUnescapedSymbolicName-119))|(1<<(CypherParserEscapedSymbolicName-119)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ILeftArrowHeadContext is an interface to support dynamic dispatch.
type ILeftArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeftArrowHeadContext differentiates from other interfaces.
	IsLeftArrowHeadContext()
}

type LeftArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftArrowHeadContext() *LeftArrowHeadContext {
	var p = new(LeftArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_leftArrowHead
	return p
}

func (*LeftArrowHeadContext) IsLeftArrowHeadContext() {}

func NewLeftArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftArrowHeadContext {
	var p = new(LeftArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_leftArrowHead

	return p
}

func (s *LeftArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *LeftArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftArrowHeadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitLeftArrowHead(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) LeftArrowHead() (localctx ILeftArrowHeadContext) {
	localctx = NewLeftArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, CypherParserRULE_leftArrowHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1552)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__18)|(1<<CypherParserT__26)|(1<<CypherParserT__27)|(1<<CypherParserT__28)|(1<<CypherParserT__29))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IRightArrowHeadContext is an interface to support dynamic dispatch.
type IRightArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRightArrowHeadContext differentiates from other interfaces.
	IsRightArrowHeadContext()
}

type RightArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRightArrowHeadContext() *RightArrowHeadContext {
	var p = new(RightArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_rightArrowHead
	return p
}

func (*RightArrowHeadContext) IsRightArrowHeadContext() {}

func NewRightArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RightArrowHeadContext {
	var p = new(RightArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_rightArrowHead

	return p
}

func (s *RightArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *RightArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RightArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RightArrowHeadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitRightArrowHead(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) RightArrowHead() (localctx IRightArrowHeadContext) {
	localctx = NewRightArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, CypherParserRULE_rightArrowHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1554)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(CypherParserT__19-20))|(1<<(CypherParserT__30-20))|(1<<(CypherParserT__31-20))|(1<<(CypherParserT__32-20))|(1<<(CypherParserT__33-20)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDashContext is an interface to support dynamic dispatch.
type IDashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDashContext differentiates from other interfaces.
	IsDashContext()
}

type DashContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDashContext() *DashContext {
	var p = new(DashContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dash
	return p
}

func (*DashContext) IsDashContext() {}

func NewDashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DashContext {
	var p = new(DashContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dash

	return p
}

func (s *DashContext) GetParser() antlr.Parser { return s.parser }
func (s *DashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CypherVisitor:
		return t.VisitDash(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CypherParser) Dash() (localctx IDashContext) {
	localctx = NewDashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, CypherParserRULE_dash)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1556)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-14)&-(0x1f+1)) == 0 && ((1<<uint((_la-14)))&((1<<(CypherParserT__13-14))|(1<<(CypherParserT__34-14))|(1<<(CypherParserT__35-14))|(1<<(CypherParserT__36-14))|(1<<(CypherParserT__37-14))|(1<<(CypherParserT__38-14))|(1<<(CypherParserT__39-14))|(1<<(CypherParserT__40-14))|(1<<(CypherParserT__41-14))|(1<<(CypherParserT__42-14))|(1<<(CypherParserT__43-14))|(1<<(CypherParserT__44-14)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}
